#coding=utf8
# import requests
# import json
# import numpy as np
# rr=requests.get('http://wthrcdn.etouch.cn/weather_mini?citykey=101010100')
# we=rr.content.decode('utf-8')
# print(we)
# we=json.loads(we)
# fengli=we['data']['forecast']
# for item in fengli:
#     ii=item['fengli'].split('[')[2].split(']')[0]
#     print(ii)

# rr=requests.get('http://www.weather.com.cn/data/sk/101020300.html')
# we=rr.content.decode('utf-8')
# print(we)
# import time
'''
# nums = [a for a in range(-4,4)]
nums = [1,2,-2,-1,-3]
nums = sorted(nums)
target = 0
print(nums)

t3 = []
start2 = time.clock()
t2 = {}
for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        if t2.get(nums[j]) is not None and j != nums.index(t2[nums[j]][0]) and j != nums.index(t2[nums[j]][1]):
            tmp = []
            tmp.append(nums[j])
            tmp += t2[nums[j]]
            if sorted(tmp) not in t3:
                t3.append(sorted(tmp))
        else:
            mark = target - nums[i] - nums[j]
            t2[mark] = [nums[i], nums[j]]
print(t2)
print(t3)

end2 = time.clock()
print("time:",(end2-start2)*1000)
'''
'''
#	删除排序数组中的重复项,返回长度
nums= []
#     [0,1,2,3]
if len(nums)==0:
    print(0)
mark = 1
for j in range(1, len(nums)):
    if nums[j] == nums[j-1]:
        continue
    else:
        nums[mark] = nums[j]
        mark += 1
print(nums)
print(mark)
'''
'''
start2 = time.clock()
height =  [28,342,418,485,719,670,878,752,662,994,654,504,929,660,424,855,922,744,600,229,728,33,371,863,561,772,271,178,455,449,426,835,143,845,321,214,867,199,967,881,193,973,386,122,633,810,330,907,906,282,136,986,315,860,849,229,632,473,759,87,922,185,922,418,382,243,632,250,795,599,131,988,924,869,463,558,680,145,465,938,427,954,925,94,814,126,323,798,599,434,885,874,620,159,292,354,755,924,956,550,876,88,890,800,309,705,358,989,850,176,280,629,130,205,724,296,331,399,94,283,186,331,157,806,490,801,512,597,725,469,499,601,909,390,754,218,447,112,560,298,640,840,279,122,397,355,418,80,755,864,363,293,195,872,451,38,673,963,635,751,432,487,352,341,229,458,912,676,923,472,326,563,312,606,686,709,313,456,789,420,321,505,713,868,377,164,258,403,128,246,154,912,733,858,606,962,317,518,990,240,990,317,803,302,275,841,363,588,650,504,9,323,9,74,191,387,239,450,790,367,48,944,279,781,802,885,743,471,755,85,711,745,402,867,399,29,708,762,970,710,267,331,33,276,405,577,15,644,379,157,363,427,453,995,208,608,232,303,79,988,388,791,733,143,658,133,524,718,247,846,429,514,529,814,143,935,743,510,931,122,668,647,901,473,642,461,81,874,764,513,214,505,304,948,0,314,433,876,384,680,75,165,547,604,980,42,891,75,552,823,198,572,822,451,46,816,913,479,42,29,992,257,886,648,557,238,962,990,115,699,22,190,864,921,794,196,315,686,272,868,861,822,792,35,273,190,851,186,670,893,568,662,150,454,311,59,693,625,49,808,324,424,350,189,697,496,737,13,534,9,881,747,831,25,782,457,216,985,643,886,879,211,900,381,18,211,441,711,837,842,871,513,618,573,702,316,69,440,329,956,801,562,703,633,587,486,90,803,471,85,41,702,649,942,436,19,505,877,730,342,71,953,856,690,526,910,6,947,702,335,903,504,249,607,489,836,445,931,992,268,368,33,971,369,327,407,388,833,636,470,527,59,423,735,749,301,646,107,249,700,794,504,556,43,111,397,232,908,328,224,177,49,609,500,418,937,259,159,770,247,629,297,306,405,33,408,706,31,867,955,83,662,460,640,57,923,37,289,832,718,865,361,119,475,213,537,412,472,48,534,71,678,183,377,83,568,137,141,599,5,449,35,19,261,675,76,184,64,366,368,134,583,81,253,58,294,143,822,118,191,356,189,221,892,919,656,460,56,798,412,61,247,447,80,508,474,509,44,538,227,765,673,810,846,278,869,493,421,43,611,613,752,153,834,644,72,491,456,128,641,868,542,888,315,974,748,141,483,144,32,710,909,705,873,108,983,94,601,757,137,564,370,241,69,556,885,141,47,694,622,688,562,516,928,230,490,28,371,326,173,403,388,82,460,613,542,796,707,495,553,197,412,275,438,481,831,676,623,231,370,597,271,284,113,200,514,955,228,238,633,753,993,374,188,806,987,730,602,695,226,507,892,638,782,330,471,965,358,94,196,728,43,468,365,508,20,879,464,600,469,449,354,463,823,542,621,811,624,223,506,850,82,750,840,216,432,312,181,791,758,730,871,802,550,236,310,570,468,126,522,289,576,228,104,751,122,725,562,747,300,420,949,382,170,790,950,603,454,132,746,564,214,969,366,764,206,29,686,26,507,208,315,435,789,420,187,911,145,101,658,446,522,608,180,692,750,131,647,556,615,393,120,181,363,839,945,921,220,983,299,727,543,614,515,332,386,54,244,884,155,254,682,29,214,862,722,964,345,721,520,960,467,993,141,182,832,438,455,52,421,754,131,317,720,646,649,107,52,245,343,208,500,25,589,714,239,311,31,585,385,903,897,852,896,391,386,728,181,841,780,955,595,264,272,315,262,921,774,315,167,117,875,19,494,464,733,86,128,116,671,513,20,920,717,916,663,103,997,845,944,129,800,891,393,72,558,656,345,333,971,512,802,846,883,649,662,617,735,790,733,406,655,105,678,372,374,342,827,371,187,123,500,339,14,246,411,573,902,108,258,225,973,60,423,856,709,85,473,444,876,559,202,531,16,233,256,390,575,83,761,114,559,614,453,573,860,216,498,114,324,756,339,649,169,762,506,230,199,979,27,427,890,581,311,259,814,567,649,389,2,763,855,561,377,660,487,589,228,337,703,905,446,42,554,615,156,60,197,707,392,576,135,282,158,446,541,324,365,543,66,367,306,921,281,35,582,768,624,810,457,327,715,903,721,270,870,229,682,68,936,74,996,423,709,154,221,250,479,586,145,545,306,451,818,587,486,400,707,462,563,164,789,630,420,862,252,290,443,935,358,732,9,355,155,718,861,729,321,692,315,466,237,973,270,56,560,108,808,619,571,723,136,712,354,556,927,958,846,370,893,557,454,255,264,610,325,477,339,998,170,6,817,759,980,87,815,892,547,976,864,470,51,0,183,405,908,462,716,754,184,961,663,639,216,927,249,894,405,940,892,927,298,709,686,630,148,854,523,696,830,387,166,881,739,701,639,647,163,707,401,348,668,417,987,237,344,588,131,101,880,375,28,178,85,67,161,233,921,684,929,103,423,448,984,162,149,975,809,665,682,562,13,703,979,352,940,676,940,423,777,172,798,158,702,883,225,863,469,498,899,750,601,322,198,937,484,348,265,293,365,299,856,378,2,187,82,294,863,374,717,993,546,516,151,248,751,728,464,220,578,363,971,179,686,169,116,522,869,381,168,234,681,376,964,35,563,46,330,427,420,47,420,318,915,923,919,667,3,383,239,581,98,562,760,136,732,228,659,953,962,827,540,995,203,856,30,118,903,712,545,675,112,317,994,27,240,913,46,243,648,638,824,746,200,936,883,284,165,894,590,127,721,130,474,276,986,504,394,241,217,292,269,329,609,263,708,202,528,107,797,176,745,974,274,945,910,157,582,427,403,172,906,124,302,380,752,640,885,499,234,454,791,503,135,752,118,843,954,646,302,104,174,47,78,800,345,988,310,927,416,713,99,322,838,753,55,942,745,940,441,979,746,584,482,881,337,952,76,643,598,379,747,124,778,825,925,123,166,235,402,934,948,853,608,138,606,663,81,704,955,874,683,701,459,518,934,148,470,363,791,421,94,891,545,872,68,822,348,234,57,102,168,358,956,129,496,914,792,929,618,748,804,654,801,263,524,736,411,994,451,554,767,545,797,313,769,866,487,117,452,545,572,973,903,528,102,751,442,246,681,413,994,485,67,148,100,591,236,863,937,687,417,705,232,567,370,353,433,857,823,237,754,395,210,9,923,664,113,717,911,794,482,257,631,549,405,83,492,641,946,782,328,715,839,912,282,561,266,715,418,89,305,525,484,515,534,759,532,999,476,443,793,959,700,776,860,106,859,705,99,805,839,428,873,678,692,155,239,958,223,9,399,528,886,235,395,773,994,927,772,823,722,566,134,423,694,346,881,554,403,332,711,242,760,584,272,805,740,863,763,315,873,515,843,759,750,238,884,745,518,657,568,240,575,54,15,269,400,248,175,804,581,887,398,693,823,671,498,915,534,262,230,759,129,425,871,879,664,755,624,534,412,544,774,987,950,790,257,351,390,784,507,971,671,905,665,847,928,163,762,463,777,345,574,906,770,445,786,786,201,762,320,965,659,95,953,609,237,562,312,979,346,819,951,370,77,616,569,357,131,331,820,909,28,747,167,799,192,953,585,745,68,906,711,727,353,16,688,942,930,1,921,628,172,224,350,601,192,919,959,324,251,131,585,279,878,752,430,423,58,16,168,126,274,231,205,979,247,893,921,177,246,194,158,419,419,508,20,963,428,331,639,31,463,224,662,341,329,93,764,739,461,285,217,735,516,422,714,764,667,987,293,914,533,451,685,304,960,57,268,740,389,907,771,852,484,433,545,165,878,310,904,339,947,121,426,463,895,492,579,914,831,873,828,365,676,865,21,988,923,289,728,312,549,851,516,385,637,61,550,515,723,806,207,670,927,985,134,174,478,713,88,309,938,269,26,615,134,48,955,409,689,684,721,590,887,589,975,524,651,877,392,726,683,599,397,962,584,883,136,414,948,577,724,239,846,102,206,332,150,161,742,192,197,815,782,85,405,758,609,408,635,353,134,671,952,883,633,889,118,122,655,419,699,731,658,897,834,216,229,336,377,323,528,927,139,311,12,896,69,973,304,56,679,790,727,631,674,361,872,792,483,528,563,534,259,221,431,445,437,12,782,167,336,310,94,827,621,458,723,42,783,379,99,462,169,826,446,843,539,670,988,374,550,551,908,162,125,691,607,914,704,389,81,392,52,527,571,673,337,294,716,473,25,167,935,194,993,733,38,885,404,378,259,306,281,168,468,406,211,76,321,915,817,754,659,869,634,230,895,323,876,611,796,253,778,84,448,123,817,838,8,573,216,268,880,849,788,348,256,999,776,929,267,594,683,278,815,669,861,710,993,89,673,789,343,803,225,791,927,43,981,287,968,549,907,848,398,47,549,654,47,325,583,666,271,619,944,439,640,805,149,633,895,175,775,590,978,0,381,257,395,714,545,364,263,804,564,661,852,113,668,899,791,603,917,414,222,861,205,863,19,355,848,914,530,623,856,860,976,237,118,371,303,15,87,566,819,652,579,671,117,247,922,260,851,839,27,425,53,232,640,72,587,489,338,469,464,194,682,440,783,800,812,86,167,899,652,986,903,231,10,21,831,284,281,682,476,308,107,529,893,748,601,832,589,939,302,53,485,336,494,268,136,658,354,303,909,358,641,813,941,651,186,772,288,467,454,764,128,914,293,21,14,246,853,603,537,507,656,22,843,502,290,331,160,996,986,70,706,628,235,647,631,421,420,919,888,226,35,368,492,328,741,506,926,947,461,463,806,118,485,2,972,127,685,133,475,672,555,181,652,790,181,635,211,953,555,451,179,942,820,24,271,913,530,197,212,992,13,19,462,850,373,434,330,58,919,805,82,474,339,734,264,872,370,475,825,277,927,4,219,99,380,842,364,911,392,577,255,405,948,69,255,321,855,585,731,775,743,814,601,434,548,866,306,270,693,131,547,620,487,119,71,868,961,436,131,705,365,738,110,313,159,366,986,14,303,717,141,398,883,743,832,432,961,138,54,654,621,954,627,109,73,698,329,386,486,812,92,851,550,554,516,709,920,502,75,576,572,217,974,455,312,807,239,273,297,646,927,919,600,906,380,25,957,61,763,443,873,207,647,423,762,163,484,34,18,559,610,942,128,937,749,440,96,341,65,393,987,993,664,587,251,396,964,208,457,727,652,330,935,651,105,697,166,589,731,536,501,694,478,981,631,580,422,727,921,839,472,908,832,137,847,84,533,811,644,991,538,296,673,825,299,779,522,466,720,606,2,221,300,833,203,283,413,977,362,334,816,834,594,1,323,441,437,209,604,81,552,142,730,225,968,29,4,842,847,77,448,850,298,100,35,853,735,448,182,97,134,351,284,728,704,959,521,493,168,125,926,720,619,8,946,939,390,302,782,237,731,582,439,30,35,474,235,770,922,770,220,408,473,856,136,529,815,9,374,984,486,300,704,106,661,2,45,51,657,179,640,388,114,80,770,149,554,358,271,829,480,843,237,953,699,726,834,515,735,208,851,222,508,555,680,521,910,77,572,919,609,213,307,723,293,430,872,199,788,495,28,268,339,618,573,38,344,407,905,431,615,756,5,475,664,685,997,574,115,921,493,724,134,152,447,779,582,671,331,370,518,359,990,857,329,563,248,673,322,153,105,289,262,462,765,926,500,114,852,615,35,345,691,522,849,490,653,432,513,984,154,31,696,145,889,25,60,489,51,383,642,508,672,904,970,789,182,470,255,34,437,643,731,128,165,581,618,170,13,483,155,519,515,203,664,756,228,77,245,631,812,239,139,836,496,110,978,678,932,233,713,722,876,796,850,41,377,821,564,742,304,719,262,171,274,278,927,502,355,524,486,519,764,625,356,612,87,334,642,20,567,707,742,444,504,944,837,881,117,401,624,774,472,238,945,746,516,225,601,224,749,87,743,513,64,99,477,152,785,120,524,705,827,266,501,331,562,338,213,32,92,189,806,916,427,103,15,295,328,968,519,78,407,263,943,471,714,421,623,852,541,147,557,368,765,58,700,680,748,265,712,192,454,870,109,233,973,476,528,302,444,48,380,851,663,323,674,729,744,650,581,637,149,490,6,267,548,58,947,297,323,11,841,129,881,950,362,206,778,890,508,222,290,240,425,305,916,100,387,660,102,320,298,251,811,656,518,711,714,817,360,37,828,202,518,61,504,880,268,283,122,128,857,765,369,283,422,637,735,809,297,189,482,947,440,645,955,959,356,669,776,69,58,957,271,576,18,127,808,638,410,931,119,268,48,840,903,470,477,990,632,126,179,114,426,971,759,381,930,467,403,59,536,813,16,159,742,386,287,550,377,49,833,496,317,881,688,572,352,165,914,336,291,445,450,69,417,561,451,699,380,206,110,917,19,478,428,761,217,715,664,594,765,497,442,434,379,130,359,83,647,625,419,290,423,221,360,192,134,163,891,514,369,2,783,740,832,564,854,49,279,518,643,396,15,437,183,746,919,894,829,566,519,600,857,294,173,217,486,307,380,378,174,101,732,309,841,916,873,695,966,505,213,961,253,229,399,788,975,318,682,157,885,554,109,742,848,283,311,335,942,691,65,468,792,149,778,985,65,3,681,31,860,894,345,466,475,744,254,803,62,289,312,299,843,421,393,43,56,704,730,999,747,147,467,891,648,597,877,714,953,558,97,813,804,442,279,632,538,534,787,953,823,99,252,18,872,998,413,929,702,496,280,802,643,747,693,292,697,570,358,650,128,807,463,285,602,95,917,140,629,704,445,804,155,50,174,27,48,939,308,750,435,588,904,431,688,598,723,385,168,433,35,649,592,850,934,194,945,203,687,926,907,132,730,414,182,256,793,582,196,102,685,983,690,589,414,378,187,489,115,356,922,150,357,867,1,291,61,946,494,100,873,753,585,955,167,119,564,312,702,760,414,387,95,457,976,510,187,516,999,303,224,274,453,581,141,806,872,554,105,718,655,978,471,592,285,990,711,849,302,765,961,69,504,57,526,833,567,713,349,918,368,573,192,174,154,333,980,378,888,85,96,895,415,919,487,701,261,550,902,915,668,216,984,172,273,862,5,192,928,706,462,296,279,655,470,785,340,451,163,580,888,611,827,304,882,314,357,143,217,611,59,237,827,395,409,100,258,767,644,186,473,107,482,105,114,305,890,806,756,406,387,996,17,214,300,900,881,9,43,450,621,454,687,448,850,96,901,460,215,897,646,689,356,480,794,470,785,36,277,893,442,16,890,460,230,542,712,111,904,107,913,525,562,600,973,764,49,226,224,264,124,222,953,480,54,99,303,192,136,580,437,578,948,679,390,178,222,102,642,478,210,555,3,772,156,328,888,557,907,464,821,31,38,775,863,444,226,166,636,362,98,74,293,46,753,683,577,327,786,219,157,996,126,160,120,634,841,360,191,748,824,13,131,862,140,994,306,718,513,295,81,611,721,726,10,826,409,587,506,547,158,663,543,284,824,15,919,17,375,462,765,199,475,896,413,967,242,72,686,755,367,119,367,440,845,729,266,606,316,772,154,474,436,697,110,612,65,29,629,440,844,746,992,319,994,405,639,236,829,677,992,548,796,711,988,993,440,255,599,108,27,105,934,815,155,44,427,220,74,408,660,918,154,652,589,148,410,580,737,239,257,729,788,405,792,776,750,584,383,702,692,763,807,626,578,962,670,358,182,96,766,195,366,273,199,308,421,609,240,158,201,850,239,341,255,31,469,6,967,853,60,659,616,867,637,546,182,660,904,364,108,671,911,475,944,111,135,717,72,375,228,273,225,819,614,833,203,84,191,170,289,251,830,905,470,819,803,652,479,708,369,588,731,280,415,27,743,902,744,816,277,324,441,855,144,56,40,347,492,583,869,781,834,51,38,656,871,841,309,350,549,678,290,632,310,705,659,406,607,756,222,237,80,15,444,576,423,484,275,915,419,145,48,253,196,86,909,67,280,570,770,181,600,60,814,263,118,473,669,725,229,243,314,662,258,758,238,682,594,514,597,13,659,998,618,207,436,880,275,716,802,45,250,403,457,64,666,575,889,335,301,471,930,967,133,188,726,723,870,672,237,820,38,248,818,656,456,606,536,83,323,339,128,925,94,937,989,112,513,230,799,166,701,729,133,186,917,211,910,788,884,499,960,922,748,130,930,556,736,819,639,411,510,119,336,604,56,677,716,569,908,515,87,961,244,221,500,513,784,410,653,20,909,613,294,9,743,225,565,480,44,204,891,906,323,580,510,732,257,578,653,517,445,741,479,41,314,979,554,98,741,208,471,2,173,765,12,917,990,577,749,386,134,992,292,809,572,154,541,830,84,195,347,529,288,178,570,602,509,477,52,250,685,523,253,858,641,265,127,631,194,876,370,680,869,14,490,441,169,383,623,253,930,971,135,218,149,705,820,659,534,225,261,219,100,514,430,741,131,909,373,678,138,95,358,7,109,200,800,630,936,424,236,866,747,371,85,248,428,257,259,963,482,521,534,583,387,316,324,871,226,49,549,364,496,259,723,958,812,875,588,748,651,176,614,398,547,51,999,328,309,258,291,143,131,825,726,871,494,403,94,72,804,995,436,301,254,511,611,418,738,199,518,390,376,133,140,275,184,139,603,845,750,246,989,233,424,67,456,918,470,550,990,627,545,778,280,152,641,891,570,379,90,89,121,818,574,262,446,110,753,401,956,855,648,945,441,424,12,249,694,835,800,684,462,697,814,742,849,807,633,772,538,75,213,660,246,787,274,44,249,379,445,205,587,445,502,380,869,867,629,563,54,429,599,868,479,765,610,328,572,595,452,463,22,665,123,620,804,749,664,54,480,110,611,67,907,466,447,129,685,77,692,739,858,644,607,337,761,569,18,686,516,470,149,538,136,624,159,292,373,175,698,853,285,310,273,545,128,720,674,165,149,718,904,8,714,863,345,476,784,715,162,300,186,311,190,674,287,701,966,660,877,665,865,514,327,138,59,807,211,733,972,360,804,876,720,518,91,418,994,875,133,508,175,319,819,717,993,458,419,312,470,296,977,336,810,656,826,870,463,389,955,435,750,759,311,470,630,754,888,624,629,374,133,156,693,304,873,39,763,292,351,233,940,680,921,751,336,100,973,799,489,280,234,239,392,545,62,22,299,302,998,280,676,483,436,722,788,309,761,903,954,464,488,894,144,410,997,480,510,970,279,351,603,513,591,995,410,5,369,61,659,367,341,688,851,129,410,991,438,523,894,744,987,382,639,131,144,988,611,6,311,242,358,914,755,301,261,517,306,630,578,317,349,919,5,552,48,415,543,838,290,789,935,277,524,926,760,668,914,371,675,225,965,33,491,72,686,752,589,992,734,167,661,436,438,667,988,838,434,884,29,725,673,964,354,197,242,115,218,156,838,893,734,804,278,225,876,964,330,466,308,416,985,969,852,776,988,841,614,775,725,995,500,750,311,854,948,553,969,166,62,808,411,796,964,41,373,840,357,703,658,17,120,996,338,324,772,327,165,738,102,242,86,954,993,397,160,293,303,130,459,365,290,222,513,606,615,886,446,972,942,457,989,414,453,327,738,577,6,904,315,460,498,401,414,491,151,575,784,454,57,595,819,699,169,332,305,784,570,103,108,512,560,449,926,365,777,665,942,135,921,610,596,419,11,362,911,514,289,47,968,698,643,787,397,164,471,54,949,42,158,57,906,70,507,833,788,636,850,730,123,123,692,71,542,56,434,805,570,75,853,539,774,848,678,171,12,150,578,313,544,736,723,802,158,230,987,946,218,837,29,693,960,721,765,855,777,199,660,348,274,865,239,400,713,917,924,78,419,502,391,315,590,114,118,748,696,105,47,266,295,428,960,255,149,725,110,279,924,123,979,550,988,218,951,702,135,875,780,907,729,523,222,319,638,340,419,686,798,466,953,93,894,913,700,396,638,163,675,914,286,654,816,274,224,119,328,359,994,460,618,75,984,841,394,974,533,166,660,331,984,613,776,879,526,477,627,516,992,654,430,278,660,599,904,884,718,233,595,65,45,214,140,29,407,887,3,940,53,16,624,37,629,752,268,508,581,895,376,573,901,807,851,561,406,756,445,124,341,393,541,386,607,682,768,14,569,123,306,622,139,282,11,121,35,280,981,616,527,357,190,429,164,393,342,922,149,788,399,842,181,940,229,140,974,997,506,543,120,812,517,612,95,881,733,130,161,714,746,40,71,288,469,588,682,164,862,183,952,613,26,485,906,607,977,880,604,483,776,76,295,645,40,742,526,125,872,39,839,971,80,263,611,901,203,293,65,417,829,369,383,855,206,289,462,183,521,418,18,649,846,314,295,887,408,173,12,633,213,204,604,645,819,567,898,374,213,316,143,42,685,526,897,244,815,711,427,689,481,446,338,327,112,633,566,520,159,931,153,724,487,109,721,306,677,619,32,242,935,175,284,973,54,181,217,869,244,996,910,725,442,249,52,906,234,971,779,393,902,932,469,389,394,190,47,423,810,431,665,97,958,949,70,12,482,639,234,726,636,144,451,430,393,855,337,628,826,116,373,80,400,843,469,794,33,868,569,195,299,234,293,258,183,715,622,17,355,856,743,991,1,546,421,394,402,110,374,228,226,748,309,979,943,130,773,976,351,695,524,2,929,817,612,465,884,235,482,239,91,226,582,92,772,4,839,526,466,213,107,45,313,768,24,256,250,149,585,601,844,109,604,774,278,216,239,162,803,73,402,895,299,984,339,424,340,178,302,159,744,409,204,57,177,228,666,428,729,251,381,574,360,985,700,990,554,291,152,357,364,906,604,16,243,944,792,583,474,94,94,570,504,298,980,33,526,646,813,608,249,195,182,961,532,882,951,438,525,103,796,889,10,752,905,253,696,49,188,523,144,635,93,0,933,425,385,812,71,551,420,320,746,602,281,630,836,584,69,361,688,217,602,50,969,860,655,18,909,195,541,405,830,986,757,764,412,143,928,835,694,348,508,792,302,141,422,490,726,491,851,766,708,805,816,30,665,823,48,927,370,941,332,201,279,90,317,43,585,245,879,279,945,387,71,247,880,845,737,606,689,940,372,749,97,540,779,115,363,179,42,86,120,374,287,400,816,956,443,401,553,674,32,498,413,455,97,294,301,186,900,990,478,625,91,575,165,871,690,881,50,732,967,523,459,606,923,627,914,718,29,467,393,413,317,158,869,766,452]
# height = [1,8,6,2,5,4,8,3,7]
area_max = 0
# for i in range(len(height)):
#     for j in range(i+1,len(height)):
#         m = min(list([height[i], height[j]]))
#         if area_max<(j-i)*m:
#             area_max = (j-i)*m
i = 0 
j = len(height)-1
while i<j:
    if height[i]<height[j]:
        m = (j-i)*(height[i])
        i += 1
    else:
        m = (j-i)*height[j]
        j -= 1
    if area_max<m:
        area_max = m
print(area_max)
end2 = time.clock()
print("time:",(end2-start2))
'''
'''
matrix = [
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
]

for i in range(len(matrix)):
    for j in range(i+1, len(matrix)):
        tmp = matrix[i][j]
        matrix[i][j] = matrix[j][i]
        matrix[j][i] = tmp
for i in range(len(matrix)):
    for j in range(int(len(matrix)/2)):
        tmp = matrix[i][j]
        matrix[i][j] = matrix[i][len(matrix)-j-1]
        matrix[i][len(matrix)-j-1] = tmp

for item in matrix:
    print(item)
# print(matrix)
'''
'''
board = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
'''
'''
def trans(m):
    for i in range(len(m)):
        for j in range(i):
            m[i][j], m[j][i] = m[j][i], m[i][j]
    return m
def fun(li, num):
    tmp = li.copy()
    tmp.remove(num)
    if num in tmp:
        return True
    else:
        return False
flag = True
for i in range(len(board)):
    for j in range(len(board[i])):
        if board[i][j] != '.':
            result = fun(list(board[i]), board[i][j])
            if result == True:
                flag = False
                break

sudu_zhuan = trans(board)
for i in range(len(sudu_zhuan)):
    for j in range(len(sudu_zhuan[i])):
        if sudu_zhuan[i][j] != '.':
            result = fun(list(sudu_zhuan[i]), sudu_zhuan[i][j])
            if result == True:
                flag = False
                break
k = 1
for i in range(len(board)):

    if i%3 == 0: # 0,3,6
        cout = 0
        for j in range(len(board)):
            tmp = []
            if j %3 == 0: # 0,3,6
                for m in range(i,i+3):
                    for n in range(j,j+3):   #00,01,02,10,11,12,20,21,22
                        tmp.append(board[m][n])
                for item in tmp:
                    if item != '.':
                        result = fun(tmp, item)
                        if result == True:
                            flag = False
                            break
if flag:
    print(True)
else:
    print(False)         
'''
'''
#皇后问题：
n = 4
def could_replace(row, col):
    return not (cols[col] + hill[row + col] + dale[row - col]) #全为零才可以放
def place_queen(row, col):
    queens.add((row, col)) #放置皇后
    cols[col] = 1 #打标记
    hill[row + col] = 1
    dale[row - col] = 1

def remove_queen(row, col):
    queens.remove((row, col))
    cols[col] = 0
    hill[row + col] = 0
    dale[row - col] = 0

def add_solution():
    solutions = []
    for _, col in sorted(queens):
        solutions.append('.' * col + 'Q' + '.' * (n - col - 1))
    output.append(solutions)

def backtrack(row = 0):
    print('row ',row)
    for col in range(n):
        print('col ', col)
        if could_replace(row, col): #判断是否可以放置
            place_queen(row, col) #放置
            if row + 1 == n:  #已放满
                add_solution()
                print('ok')
            else: #未放满，继续递归
                print('else')
                backtrack(row + 1)
                print('back ')
            remove_queen(row, col)
            print('remove')
cols = [0] * n #行
hill = [0] * (2 * n - 1) #左下右上
dale = [0] * (2 * n - 1) #右下左上
queens = set()
output = []
backtrack()
for item in output:
    print(item)
print(len(output))
'''
'''
height = [0,1,0,2,1,0,1,3,2,1,2,1]
if len(height) <=1:
    print(0)
num = len(height)
vol = 0
left_max = [0]*num
right_max = [0]*num
left_max[0] = height[0]
right_max[-1] = height[-1]
for i in range(1, num-1):
    left_max[i] = max(height[i], left_max[i-1])
for i in range(num-2, -1, -1):
    right_max[i] = max(height[i], right_max[i+1])

print(left_max, )
print(right_max)
for i in range(1,num-1):
    tmp = min(left_max[i], right_max[i]) - height[i]
    if tmp <= 0:
        tmp = 0
    vol += tmp
print(vol)
'''
'''
#二分查找法，查找数组中指定目标的左右边界：
a = [2,2]
target = 6
left = 0
right = len(a)-1  #9
result = []
#left
while left < right:
    mid = int((left + right)/2)
    print(left,right,mid,)
    if a[mid] == target:
        print(mid)
        right = mid
        # break
    elif a[mid] < target:
        left = mid + 1
    elif a[mid] > target:
        right = mid 
print(":",left)
result.append(left)
#right
left = 0
right = len(a)
while left < right:
    mid = int((left + right)/2)
    print(left,right,mid,)
    if a[mid] == target:
        print(mid)
        left = mid +1
        # break
    elif a[mid] < target:
        left = mid + 1
    elif a[mid] > target:
        right = mid
print(":",left-1)
result.append(left-1)
# print(result)
if a[result[0]] != target:
    result[0] = -1
if a[result[1]] != target:
    result[1] = -1
print(result)
'''

# s = "leetcode"
# wordDict = ["leet", "code"]
'''
#蒙特卡罗随机算法求PI：
import random
total = 50000000 #模拟点数量
in_count = 0
for i in range(total):
    x = random.random()
    y = random.random()
    dis = (x**2+y**2)**0.5
    if dis <=1:
        in_count +=1
print(4*in_count/total)
'''
'''
#蒙特卡罗求一个图片的某个颜色像素数量：
from PIL import Image
import random
img = Image.open('/Users/xutao/Downloads/te.jpg')
total = 500000
in_count = 0
#随机遍历求解：
for i in range(total):
    x = random.randint(0,img.width-1)
    y = random.randint(0,img.height-1)
    # print(img.getpixel((x,y)))
    col = img.getpixel((x,y))
    if col == (249,9,10):
        in_count += 1
#遍历一遍求准确解：
co = 0
for i in range(img.width):
    for j in range(img.height):
        col = img.getpixel((i,j))
        # print(col)
        if col == (249,9,10):
            co += 1
print("准确解:", co, "模拟解:", img.width*img.height*in_count/total)
'''

'''
#适用tpot：
from tpot import TPOTClassifier
from sklearn.cross_validation import train_test_split
import numpy as np
import pandas as pd
names=['alloy','class','delta','Hmix','Smix','Fi','RMS','VEC','r','Sc','deltaHmixmax','deltaHmixmin','rootHmix','rootHmix0','rootHmix0+','rootHmix0-']
data=pd.read_csv('/Users/xutao/Nustore Files/我的坚果云/HEA/合并数据集-去除重复.csv',header=0,names=names) #/Users/xutao/Nustore Files/我的坚果云/HEA #/Users/xutao/Downloads/Python/HEA/

Y=data[["class"]]
X=data[['delta','Hmix','Smix','Fi','RMS','VEC','r','Sc','deltaHmixmax','deltaHmixmin','rootHmix','rootHmix0','rootHmix0+','rootHmix0-']]
X_train, X_test, y_train, y_test = train_test_split(X, Y, train_size=0.7, test_size=0.3)

tpot = TPOTClassifier(generations = 7, population_size = 50, verbosity=2, n_jobs=-1)
tpot.fit(X_train, y_train)
print(tpot.score(X_test, y_test))
'''

'''
#递归求全排列：
st = []
def perm(list,stack): #求解函数。
    if not list: #list为空
        tm = stack.copy() #单独copy一份新数组，防止因stack只是修改而内存地址未变化，而导致st中加入的都是一样的数组。
        st.append(tm)
    else:  # 没有到树的叶子节点的时候，使用递归继续往下找。
        for i in range(len(list)):
            stack.append(list[i])
            del list[i]
            perm(list,stack)
            list.insert(i,stack.pop())
list=[1,2,3]
def permute(nums): #调用函数只有一个数组参数的要求。
    stac = []
    perm(nums,stac)
permute(list)
print(st)
'''
'''
#只出现一次的数字
#Hash法：
li = [1,3,2,4,1,2,4]
t = {}
for item in li:
    try:
        t.pop(item)
    except:
        t[item] = 'x'
        # print(t)
print(t.popitem()[0])
#位运算：异或：
t = 0
for item in li:
    t = t^item
print(t)
#数学公式：
print(2*sum(set(li))-sum(li))
'''


'''
#最大子序列和:
#法1：
def max_S1(nums):
    max_ = nums[0]
    tmp = max_ #记录当前序列和
    for i in range(1, len(nums)):
        if tmp + nums[i] > nums[i]: #变大了
            max_ = max(max_, tmp + nums[i])
            tmp = tmp + nums[i]
        else:
            max_ = max(max_, nums[i])
            tmp = nums[i]
    print(max_)
#法2：
#分治法，最大子序列和，要么在左半边，要么在右半边，要么跨越中间横跨两边。
#所以递归求解左、右最大最大子序列的和与横跨中间的和进行比较
def maxSubArray(nums):
    print("进：",nums)
    n = len(nums)
    if n == 1:
        print("if:",nums)
        return nums[0]
    else:
        #递归计算左半边最大子序和
        print("left:")
        max_left = maxSubArray(nums[0:len(nums) // 2])
        print("max_left:",max_left)
        #递归计算右半边最大子序和
        print("right:")
        max_right = maxSubArray(nums[len(nums) // 2:len(nums)])
        print("max_right:",max_right)
        print("all:")
    print("here:",max_left,max_right)
    print("nums:",nums)
    #计算从中间开始向左边累加的最大和：
    max_l = nums[len(nums) // 2 - 1]
    tmp = 0
    for i in range(len(nums) // 2 - 1, -1, -1):
        tmp += nums[i]
        max_l = max(tmp, max_l)
    #计算从中间开始向右边累加的最大和：
    max_r = nums[len(nums) // 2]
    tmp = 0
    for i in range(len(nums) // 2, len(nums)):
        tmp += nums[i]
        max_r = max(tmp, max_r)
    #返回三个中的最大值
    print("tmp:",max_left,max_right,max_l+max_r)
    return max(max_right,max_left,max_l+max_r)
nums =[-1,3,1,-2,4,2]
# max_S1(nums)
print(maxSubArray(nums))
'''

#跳跃游戏：
'''
#法1：动态规划1：
#超出时间限制了，最大时间复杂度O(n^2)
def canJump(nums):
    flag = False
    for i in range(1, len(nums)):
        flag = False
        for j in range(i-1, -1, -1):
            if nums[j] >= i - j: #判断能否从j跳到i，跳不到直接return false
                flag = True
                break
        if not flag:
            return False
    return True

#法3：
# 使用贪心的思路看下这个问题，我们记录一个点的坐标代表当前可达的最后节点，这个坐标初始等于nums.length-1，
# 然后我们每判断完是否可达，都向前移动这个坐标，直到遍历结束。
# 如果这个坐标等于0，那么认为可达，否则不可达。
def canJump(nums):
    lastPosition = len(nums) - 1;
    for i in range(len(nums) - 1,-1,-1) :
        if (nums[i] + i >= lastPosition) : #数组元素要大于等于lp减去i的值才表示当前i位置可跳到i+1的位置
            print(lastPosition)
            lastPosition = i #向前移动坐标，如果if条件不满足，无法完成跳跃，lp的值保留，继续探测前一个位置，如果最终能完成跳跃，则lp的值应为最后一个i值即0.
            
    return lastPosition == 0
'''
'''
def jug_eli(A,x,y): #寻找[x,y]上下左右相同数字的坐标索引。以数组形式返回
    target = A[x][y]
    t = []
    s = {}
    for i in range(y+1,5):
        if target == A[x][i]: #横-右
            t.append([x,i])
        else:
            break
    for i in range(y-1,0,-1):
        if target == A[x][i]: #横-左
            t.append([x,i])
        else:
            break
    for i in range(x-1,0,-1):
        if target == A[i][y]: #竖-上
            t.append([i,y])
        else:
            break
    for i in range(x+1,5):
        if target == A[i][y]: #竖-下
            t.append([i,y])
        else:
            break
    return t
'''
'''
A = [
[3, 1, 2, 1, 1],
[1, 1, 1, 1, 3],
[1, 1, 1, 1, 1],
[1, 1, 1, 2, 1],
[3, 1, 2, 2, 2]]
# print(jug_eli(A,4,4))
'''
'''
#括号生成
n=3
t = []
def back(S = '', left = 0, right = 0):
    if len(S) == 2*n:
        t.append(S)
    if left < n:
        back(S+'(',left + 1, right)
    if right < left:
        back(S+')',left, right + 1)
back()
print(t)

def scope_test():
    def do_local():
        spam = "local spam" #此函数定义了另外的一个spam字符串变量，并且生命周期只在此函数内。此处的spam和外层的spam是两个变量，如果写出spam = spam + “local spam” 会报错
    def do_nonlocal():
        nonlocal  spam        #使用外层的spam变量
        spam = "nonlocal spam"
    def do_global():
        global spam
        spam = "global spam"
    spam = "test spam"
    do_local()
    print("After local assignmane:", spam)
    do_nonlocal()
    print("After nonlocal assignment:",spam)
    do_global()
    print("After global assignment:",spam)

scope_test()
print("In global scope:",spam)
'''
'''
str = 'a<<b((c)<)'
s = input()
print(s)
t = []
count = 0 #等于0表示不再括号中
for i in range(len(s)):
    if s[i] == '<' and count == 0:
        if len(t) !=0:
            t.pop()
    if s[i] == '(':
        count += 1
    if s[i] == ')':
        count -= 1
    if count == 0 and s[i] != '(' and s[i] != ')' and s[i] != '<':
        t.append(s[i])
    print(t)
print(t)
st = ''
for item in t:
    st += item
print(st)
'''
# s = input().strip(' ')
# print(s)

'''
#小红书笔试编程题 答案不对。。。
import sys
N = input()
i = 0
t = []
while i < int(N):
    tmp = []
    s = input().strip(' ')
    t.append([])
    t[i].append(s[0])
    t[i].append(s[2])
    i += 1
tt = sorted(t,key=lambda x: max(x[0],x[1]))
for i in range(len(tt)-1):
    if tt[i][0] == tt[i+1][0]:
        if tt[i][1] > tt[i+1][1]:
            tt[i], tt[i+1] = tt[i+1], tt[i]
    if tt[i][1] == tt[i+1][1]:
        if tt[i][0] > tt[i+1][0]:
            tt[i], tt[i+1] = tt[i+1], tt[i]
print(tt)
count = 0
tmp = tt[0]
for i in range(len(tt)):
    if tt[i][0] >= tmp[0] and tt[i][1] >= tmp[1]:
        count += 1
        tmp = tt[i]
print(count)
'''
'''
import random
#切割钢条问题
n = 7
#递归求解：
p = [1,5,8,9,10,17,17,20,24,30]
# p.append(1)
# for i in range(1,n):
#     p.append(p[i-1]+random.randint(1,10))
# print(p)
# p = [1,5,8,9,10,17,17,20,24,30]
def cut_rod(p,n):
    # print(n)
    if n == 0:
        return 0
    q = 0
    for i in range(n):
        q = max(q, p[i] + cut_rod(p, n - i - 1))
    return q
# print('递归解：',cut_rod(p, n))
#动态规划求解：
#自顶向下法：
r = []
for i in range(n): #辅助数组，初始化为负值
    r.append(-1)
def memoized_cut_rod_aux(p,n,r):
    if r[n-1] >= 0: #检查所需值是否已知，是就返回。
        return r[n-1]
    if n == 0: #如果不已知，接下来计算
        q = 0
    else:
        q = 0
        for i in range(n):
            q = max(q, p[i] + memoized_cut_rod_aux(p, n - i - 1, r)) #分割两段，递归求解
    r[n - 1] = q #记录每种分割的值

    return q
# print('动态解：',memoized_cut_rod_aux(p,n,r))
# def cut_rod_dy(p, n):
#动态规划法2：
def bottom_up_cut_rod(p, n):
    r = []
    s = []
    r.append(0)
    for j in range(1,n+1): #按升序求解规模从1到n的子问题的解
        q = 0
        t = 1
        for i in range(1, j):
            # q = max(q, p[i] + r[j - i - 1])
            if q < p[i] + r[j - i - 1]:
                q = p[i] + r[j - i - 1]
                t = i
                s.append(i)
        r.append(q)
    return r[n], s
a, b = bottom_up_cut_rod(p,n)
# print(a, b)
while n > 0:
    # print(b[n-1])
    n -= b[n-1]
'''
# st ='ssdwer32AFW机234asfWQW关法23wrDW人'

# t = filter(lambda ch : ch not in 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',st)
# print(''.join(list(t)))


# import re

# st = '-0.001 * (Fi*(logVEC)*(pow2r)) & 0.001 * ((pow2Smix)*(pow1/2Fi)*(pow2rootHmix)) & -0.001 * ((logHmix)*(pow3VEC)*(pow1/2rootHmix0+)) & 0.001 * ((logFi)*(pow2VEC)*(logVEC)) & -0.001 * ((pow1/2Hmix)*(pow3VEC)*(pow1/2rootHmix0+)) & 0.001 * ((logFi)*(pow3VEC)*(pow2rootHmix0+)) & -0.001 * (VEC*(logHmix)*(pow2VEC)) & 0.001 * ((pow1/2Smix)*(logFi)*(pow2VEC)) & -0.001 * (Fi*deltaHmixmax*(logHmix)) & 0.001 * (VEC*(pow2VEC)*(logVEC)) & 0.001 * (VEC*(pow3VEC)*(pow2rootHmix0+)) & 0.001 * ((pow1/2Fi)*(pow3VEC)*(pow2rootHmix0+)) & -0.001 * (Fi*r*(logHmix)) & 0.001 * ((pow2VEC)*(logVEC)*(pow1/2deltaHmixmin)) & -0.001 * (VEC*rootHmix0+*(pow2Hmix)) & -0.001 * (VEC*(pow3VEC)*(logrootHmix)) & 0.001 * (Hmix*(pow2VEC)*(pow1/2rootHmix0+)) & -0.001 * ((pow1/2Fi)*(pow2deltaHmixmin)*(pow2rootHmix0+)) & 0.001 * (Smix*(pow2VEC)*(logVEC)) & -0.001 * ((pow3VEC)*(logVEC)*(pow1/2rootHmix0+)) & 0.001 * (Fi*(pow1/2Smix)*(pow1/2deltaHmixmax)) & -0.001 * ((logHmix)*(pow2Smix)*(logVEC)) & -0.001 * (Fi*(pow2Hmix)*(pow1/2rootHmix0+))'
# st_l = st.split('&')
# r = []
# for item in st_l:
#     r.append(item.strip(' '))
#     print(item)
# print(r)


#排列组合问题
# N = input() #整数N
# st = input()
# t = st.split(' ')
# A = []
# count = 0
# for item in t:
#     A.append(int(item))

# P = []
# for i in range(1,int(N)+1):
#     P.append(int(i))

# length = len(A)
# tmp = []
# def ss(lt):
#     from itertools import permutations
#     result = []
#     for item in list(permutations(P)):
#         result.append(list(item))
#     return result
# tmp = ss(A)
# print('tmp',tmp)

# for i in range(len(tmp)):
#     flag = True
#     for j in range(len(tmp[i])-1):
#         if A[j] == 1 and tmp[i][j] < tmp[i][j+1]:
#             flag = False
#             break
#         if A[j] == 0 and tmp[i][j] > tmp[i][j+1]:
#             flag = False
#             break
#     if flag:
#         count += 1
# print(count)

# s = sys.stdin.readline().strip('\n')

'''
#机器人问题
import sys
height = []
n = int(sys.stdin.readline().strip())

line = sys.stdin.readline().strip()
values = list(map(int, line.split()))
for item in values:
    height.append(item)
print(height)
max_list = []
for i in range(len(height)):
    count = 0
    tmp = height[i] 
    height_tmp = []
    for j in range(i+1,len(height)):
        if height[j] >= tmp:
            break
        if j - i > 1:
            height_tmp.append(height[j-1])
        if len(height_tmp) == 0:
            max_t = 0
        else:
            max_t = max(height_tmp)
        if height[j] < tmp and height[j] > max_t:
            count += 1
    max_list.append(count)
print(max_list,count)
index_t = max_list.index(max(max_list))
print(height[index_t])
'''

#编码解码
# str_input = input()
# t = []
# while str_input != 0:
#     tmp = int(str_input)%10
#     t.append(tmp)
#     str_input=int(str_input)/10
# t.pop()
# tt = []
# for i in range(len(t)-1,-1,-1):
#     tt.append(t[i])
# letter = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
# out = []
# def letter(nums1,nums2):
#     tm = ''
#     if len(nums1) <= 2:
#         tm += str(nums1[0])
#         tm += str(nums1[1])
#         if int(tm) <= 26:
#             return letter[int(tm)]
#     if len(nums1) == 1:
#         return letter[nums[0]]
#     st1 = letter(nums2[0], nums2[1:])
#     st2 = letter(nums2[0:2],nums2[2:])
#     out.append(st1)
#     out.append(st2)
#     return out
    
# print(letter(tt[0:2],tt))
# print(out)
# tmp = ''
# for i in range(len(tt)):
#     tmp += letter[tt[i]]
# out.append(tmp)
# print(out)



#数组相乘求第k大值，结果不太对
# k = int(input())
# nums = [x for x in range(500000)]
# nums.sort(reverse = True)
# print(nums)
# n = 5
# l = []
# for i in range(1,n):
#     for j in range(i):
#         tmp = []
#         tmp.append(j)
#         tmp.append(i)
#         l.append(tmp)
#         if len(l) == k:
#             break
#         # print(j,i)
# print(l)
# print(l[k-1][0],l[k-1][1])
# print(nums[l[k-1][0]]*nums[l[k-1][1]])


#登台阶问题
'''
k = 4
nums = [[1,1],[2]]
def climb(nums, n):
    # print(nums)
    if len(nums) == k:
        return nums
    for i in range(len(nums)):
        nums[i].append(1)
    tmp = [1]*(len(nums)-1)
    tmp.append(2)
    nums.append(tmp)
    nm = climb(nums, n+1)
    return nums
# t = climb(nums,k)
# print(t)
'''

#爬楼梯，每次只能爬一个或两个台阶，求爬到第n个台阶有多少种方法。
# n = input() #输入需要爬多少个楼梯
# i = 1
# t = []
# while i <= int(n):
#     t.append(input()) #每个楼梯的台阶数
#     i += 1

# def cl(n):
#     if n == 1:
#         return 0
#     if n == 2:
#         return 1
#     if n == 3:
#         return 2
#     j, k = 1, 2
#     s = 0
#     i = 4
#     while i <= n:
#         s = j + k
#         j, k = k, s
#         i += 1
#     return s
# for item in t:
    # print(cl(int(item)))

#不同路径：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
#机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，问总共有多少条不同的路径？
# 法1：排列组合：
# 机器人总共需要走 m+n-2步，只需要找到其中哪几步向下或向右走就可以了。
# m,n = 500,500
# x = min(m,n) - 1
# y = m+n-2
# m_x, m_y = 1, 1
# l = x
# for i in range(l):
#     m_x *= x
#     m_y *= y
#     y -= 1
#     x -= 1
# print(int(m_y/m_x))

#法2：动态规划，到达每个格子的路径数都是到达其上和其左的路径数之和，而且第0行和第0列上所有格子的路径都是1，这样先初始化第0行和第0列，然后从[0,0]开始往后计算就可以了。
# c = [[]]
# c[0].append(0)
# for i in range(n):
#     for j in range(m):
#         if i == 0:
#             c[0].append(1)
#         if j == 0 and i !=0:
#             c.append([])
#             c[i].append(1)
#         if i != 0 and j != 0:
#             c[i].append(c[i][j-1] + c[i-1][j])
# print(c[-1][-1])

#个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
# 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
# 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
# obstacleGrid = [
#   [0,0,0],
#   [0,1,0],
#   [0,0,0]
# ]
# m, n = len(obstacleGrid), len(obstacleGrid[0])
# c = [[]]
# if obstacleGrid[0][0] == 1:
#     print(0)
# if len(obstacleGrid) == 1 and len(obstacleGrid[0]) == 1 and obstacleGrid[0][0] == 0:
#     print(1)
# else:
#     c[0].append(0)
# hexg = [0]*(max(m,n)+1)
# flag2 = True
# for i in range(m):
#     count = 0
#     flag = True
#     for j in range(n):
#         if i == 0:
#             if j < n-1 and flag:
#                 if obstacleGrid[0][j+1] == 0:
#                     c[0].append(1)
#                 else:
#                     flag = False
#                     c[0].append(0)
#             if j < n-1 and not flag:
#                 c[0].append(0)
#         if j == 0 and i != 0 and flag2: #列
#             c.append([])
#             if obstacleGrid[i][0] == 0:
#                 c[i].append(1)
#             else:
#                 flag2 = False
#                 c[i].append(0)
#         elif j == 0 and i != 0 and not flag2: #列
#             c.append([])
#             c[i].append(0)
            
#         if i != 0 and j != 0:
#             if obstacleGrid[i][j] == 0:
#                 c[i].append(c[i-1][j] + c[i][j-1])
#             else:
#                 c[i].append(0)

# print(c[-1][-1])

# import sys 
# for line in sys.stdin:
#     a = line.split()
#     print(int(a[0]) + int(a[1]))


#以下三题是58同城的算法题：：
#字符串不同元素个数：
# si = input()
# s = si.split(',')
# print(s)
# t = {}
# for item in s:
#     if item in t.keys():
#         pass
#     else:
#         t[item] = '1'
# print(t,'\n',len(list(t.keys())))



#学生排队发月饼，从左到右，右边比左边高，那么右边要比左边多发一个，最少发一个。输出最少月饼数
# import sys 
# n = int(input())#学生个数
# i = 1
# st = []
# while i <= n:
#     st.append(int(input()))
#     i += 1
# count = [1]
# flag = True
# for i in range(1,len(st)):
#     if st[i] > st[i-1]: #大
#         count.append(count[i-1]+1)
#         flag = True
#     else:
#         flag = False
#         count.append(1)
# for i in range(len(st) - 2, -1, -1):
#     if st[i] > st[i+1] and count[i] <= count[i+1]:
#         count[i] = count[i+1] + 1
# print(count,sum(count))


'''
#最小路径，输入二维矩阵，每个矩阵元素表示路径权重，输出最小路径权重。
m = int(input()) #行
n = int(input())
nums = []
i = 1
while i <= m:
    si = input()
    s = si.split()
    nums.append([])
    for item in s:
        nums[i-1].append(int(item))
    i += 1
print(nums)

weight = []
weight.append([nums[0][0]])
for i in range(1,n):
    weight[0].append(nums[0][i] + weight[0][i-1])
print('w1',weight)


for j in range(1,m):
    weight.append([])
    weight[j].append(nums[j][0] + weight[j - 1][0])
print('w2',weight)

for i in range(1,m):
    for j in range(1,n):
        tmp = min(weight[i-1][j], weight[i][j-1]) + nums[i][j]
        weight[i].append(tmp)
    print(weight)
print(weight)
print(weight[-1][-1])
'''

'''
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
为了尽快到达公主，骑士决定每次只向右或向下移动一步。
编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
'''
'''
def calculateMinimumHP(dungeon):
    s = [[1 - dungeon[-1][-1]]] if dungeon[-1][-1] < 0 else [[1]]  #或： s = [[max(1 - dungeon[-1][-1], 1)]]
    
    m = len(dungeon) #行
    n = len(dungeon[0]) #列
    for i in range(n - 2, -1, -1):
        if s[0][n - 2 - i] > dungeon[-1][i]:
            s[0].append(s[0][n - 2 - i] - dungeon[-1][i])  #s矩阵要转置，dungeon的最后一个元素是s的第一个元素。
        else:
            s[0].append(1)
    for i in range(m - 2, -1, -1):
        s.append([])
        if s[m-2-i][0] > dungeon[i][-1]:
            s[m - 1 - i].append(s[m-2-i][0] - dungeon[i][-1])
        else:
            s[m - 1 - i].append(1)
    # print(s)
    for i in range(n - 2, -1, -1):
        for j in range(m - 2, -1, -1):
            # print(s[m-2-j][n-1-i], s[m-1-j][n-2-i], dungeon[j][i])
            if dungeon[j][i] < min(s[m-2-j][n-1-i],s[m-1-j][n-2-i]):
                tmp = min(s[m-2-j][n-1-i],s[m-1-j][n-2-i]) - dungeon[j][i] #转置元素，有点复杂 头晕 绕。
            else:
                tmp = 1
            s[m-1-j].append(tmp)
    # print(s)
    return s[-1][-1] #因为是转置，最后一个元素即是起点的最小要求值。
'''

# import sys
# line = sys.stdin.readline().strip()
# values = list(map(int, line.split()))
# powv = list(map(lambda x : x**2, values))
# print(values)

#中序转前序或后序规则：
# 中转后序：输入操作符 <= 栈顶，则出栈，否则进栈。
# 中转前序：
# 1，表达式翻转；
# 2，数字直接输出，输入操作符 < 栈顶，则出栈，否则进栈。
# 3，全部输出完毕，整个表达式再翻转，即为前序。


#最长回文字符串:
'''
s = "xxxxbbbbabadffffffdghhhhhhgggggg"
start, end = 0, 0 #初始化定义首尾下标
s1 = [''] #维护一个列表，保存当前找到的最长子串
if len(s) == 1: #长度为1，直接返回改字符
    print(s[0])
def judge_string(s, left, right): #定义函数，从left和right位置向两边扩散寻找最长子串
    l, r = left, right
    while l >= 0 and r <= len(s) - 1 and s[l] == s[r]:
        l -= 1
        r += 1
    return r - l -1 #当前回文子串的长度
for i in range(len(s)-1):
    flag = False
    len1 = judge_string(s, i, i) #中心为单个字符
    len2 = judge_string(s, i, i+1) #中心为两个字符中间
    # print(s[i], 'len1:', len1, 'len2:', len2)
    start, end = (i - (len1 - 1) / 2, i + (len1 - 1) / 2) if len1 > len2 else (i - (len2/2) + 1, i + (len2/2)) #哪个长，就用哪个计算前后下标
    # print(start, end, s[int(start):int(end) + 1])
    print(s1[-1], s[int(start):int(end) + 1])
    while s1 and len(s1[-1]) < len(s[int(start):int(end) + 1]): #如果当前列表中子串比此次找到的子串短，就向前逐个删除。
        s1.pop()
        flag = True
    if flag or len(s1[-1]) <= len(s[int(start):int(end) + 1]): #已经删完，或者当前找到的子串比列表中存在的都长，就加入列表。
        s1.append(s[int(start):int(end) + 1])
print(s1) #s1的最后一个元素就是最后一个找到的最长回文子串
'''


#递归修饰器：
# @functools.lru_cache

#最短回文串,给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
#1，暴力解法，找出从从第一个字符开始的最长回文子串，然后将剩余的字符串翻转添加到前面即可。
# s = "ab"
# if len(s) == 1:
#     print(s)
# if len(s) == 0:
#     print('')
# def judge_str(st): #判断字符串是否为回文
#     i, j = 0, len(st) - 1
#     while i <= j:
#         if st[i] == st[j]:
#             i += 1
#             j -= 1
#         else:
#             break
#     return True if i > j else False
# max_st = s[0]
# mark = 0 #最长回文子串的末尾下标。
# for i in range(len(s)):
#     tmp = s[0:i + 1]
#     if judge_str(tmp):
#         if len(tmp) > len(max_st): #拿到最长回文子串
#             max_st = tmp
#             mark = i
# left_string = s[mark + 1:len(s)] #切出余下的字符串
# print(left_string,left_string[::-1]) #[::-1]将字符串翻转
# new_string = left_string[::-1] + s
# print(new_string)

#法2，从后向前遍历，判断当前的前段字符串是否为回文，如果是则停止，当前字符串是最长子串。
# mark = len(s) - 1
# while mark > 0:
#     tmp = s[0:mark + 1]
#     tmp_reverse = tmp[::-1]
#     if tmp != tmp_reverse:
#         mark -= 1
#     else:
#         break
# new_string = s[mark + 1:len(s)][::-1] + s
# print(new_string)


# # 近似误差：可以理解为对现有训练集的训练误差。
# # 估计误差：可以理解为对测试集的测试误差。

#法3：
# #KMP算法:
# def cal_next(st):
#     next_list = [-1]
#     j = 0
#     point = -1
#     while j < len(st) - 1:
#         # print(point, j, st[j], st[point])
#         if point == -1 or st[j] == st[point]:
#             point += 1
#             j += 1
#             next_list.append(point)
#         else:
#             point = next_list[point]
#             print(point)
#     print(next_list)
#     return next_list

# def KMP_match(shots, longs, next_l):
#     i, j = 0, 0
#     while i < len(longs) and j < len(shots):
#         if j == -1 or shots[j] == longs[i]:
#             i += 1
#             j += 1
#         else:
#             j = next_l[j]
#     if j == len(shots):
#         print("下标:",i-j)
#     else:
#         print("fail")

# s1 = "adcbaacdabcfabcd2"
# s2 = 'aacda'
# KMP_match(s2, s1, cal_next(s2))

# s_rev = s[::-1] #翻转
# s_new = s + '#' + s_rev #拼接
# next_s = cal_next(s_new)#计算next数组
# ss = s_rev[:len(s)-1 - next_s[len(s_new)-1]] #计算前缀
# s_last = ss + s #拼接
# print(s_last)



#寻找数组的索引最大的山峰，山峰：大于两边的元素。
# import sys
# # li = list(map(int,input().split()))
# line = sys.stdin.readline().strip()
# li = list(map(int, line.split()))
# print(li)
# print(li)
# tmp = li[0] #初始化第一个为山峰
# peak_index = 0
# for i in range(1, len(li)):
#     t = li[i]
#     if t > li[i-1] and t > li[i + 1] and t >= tmp:
#         tmp = t 
#         peak_index = i
# print(tmp, peak_index)

# import sys
# i = 1
# datalist = []
# while i <= 2:
#     line = sys.stdin.readline().strip()
#     datalist.append(list(line.split()))
#     i+=1
# print(datalist)
# print(datalist[0][1])
# work_hour = [datalist[0][1]]
# for i in range(1, len(datalist[1])):
#     if i%2 == 0:
#         # print(datalist[1][i])
#         work_hour.append(int(datalist[1][i]))
# # print(sum(work_hour[1:]))
# work_hour.append(sum(work_hour[1:]))
# work_hour[0] = work_hour[0][0].upper() + work_hour[0][1:]
# print(work_hour)
# print('{} {} {} {} {}'.format(work_hour[0], work_hour[1],work_hour[2],work_hour[3],work_hour[4]))


#电信笔试题1，一个数组，只有一个元素出现1次，其他都出现两次，输出出现一次的元素
# import sys
# n = input()
# line = sys.stdin.readline().strip()
# values = list(map(int, line.split()))
# print(values)
# print(2*sum(set(values)) - sum(values))

#电信笔试题2，输入两个字符串中间分号隔开，将其中一个字符串的相同字符用其他字符替代，如果两个字符串可完全一样，则输出True。
# import copy
# s = 'absssd'
# s.replace(s[2],'x')

# def change(st, chars, x): #替换字符函数
#     mark = []
#     char = st[x]
#     for i in range(len(st)): 
#         if st[i] == char: #替换x处的字符为chars
#             st = st[:i] + chars + st[i+1:]
#             mark.append(i)
#     return st,mark
# # print(change(s,'x',2))
# string = sys.stdin.readline().strip().split(';')
# string1 = string[0]
# string2 = copy.copy((string[1]))
# print(string1,string2)
# # if len(string1) != len(string2):
# #     return False
# mark_list = []
# for i in range(len(string1)):
#     if string1[i] != string2[i] and i not in mark_list:
#         print(string1[i], string2[i])
#         string2, tmp = change(string2, string1[i], i)
#         print(string2)
#         mark_list += tmp
# print(string1,string2)
# print(mark_list)
# if string1 == string2:
#     print(True)
# else:
#     print(False)


#电信笔试题3，输入数组，输出最大子序和，只通过80%
#数组方式输入：
# nums=[2,4,-2,5,-6]
# line = sys.stdin.readline().strip()
# values = list(line.split(','))
# lis = []
# lis.append(int(values[0].split('[')[1]))
# for i in range(1,len(values) - 1):
#     lis.append(int(values[i].strip()))
# lis.append(int(values[-1].strip().split(']')[0]))

# import sys
# T = int(input())
# i = 1
# input_list = []
# while i <= T:
#     tmp = sys.stdin.readline().strip()
#     value = list(map(int, tmp.split()))
#     input_list.append(value)
#     i += 1
# print(input_list)


#n行m列矩阵，[a][b]位置元素大小为c，其位置的上下左右比c小1，再往外扩展一圈，再小1，最小为0，输出一个给定5个参数的矩阵。
# def matrix_generate(n, m, a, b, c):
#     matrix = []# [[0*y for y in range(m)]]*n
#     for i in range(n):
#         matrix.append([])        
#         if i < a:
#             tmp = c - a + i if c - a + i >0 else 0
#         elif i > a:
#             tmp = c-i +a if c - i + a >0 else 0
#         else:
#             tmp = c
#         for j in range(m):
#             if j < b:
#                 t = tmp - b + j if tmp - b +j  > 0 else 0
#             elif j > b:
#                 t = tmp + b - j if tmp + b - j > 0 else 0
#             else:
#                 t = tmp
#             matrix[i].append(t)
#     return matrix

# for i in range(len(input_list)):#矩阵个数
#     f#or j in range(input_list[i]) #
#     n = input_list[i][0]
#     m = input_list[i][1]
#     a = input_list[i][2]
#     b = input_list[i][3]
#     c = input_list[i][4]

# matr = matrix_generate(8,8,3,3,3)
# for item in matr:
#     print(" ".join(str(s) for s in item))



#第一行输入两个数，代表n行m列，从第二行开始输入每行的元素，空格隔开，连续输入两个矩阵，计算((A^*B)*(B^))^，^代表转置。
# tmp = sys.stdin.readline().strip()
# value = list(map(int, tmp.split()))
# n, m = value[0],value[1]
# i = 1
# matrix=[]
# while i <= 2:
#     i += 1
#     j = 1
#     t = []
#     while j <= n:
#         j+=1
#         tmp = sys.stdin.readline().strip()
#         value = list(map(int, tmp.split()))
#         t.append(value)
#     matrix.append(t)
# print(matrix)
# import numpy as np
# matrix = [[[1, 2], [3, 4]], [[4, 3], [2, 1]]]
# A = matrix[0]
# B = matrix[1]
# def change(matrix):#矩阵转置函数
#     m = len(matrix) 
#     n = len(matrix[0])
#     t = []
#     for i in range(n):
#         t.append([])
#         for j in range(m):
#             t[i].append(matrix[j][i])
#     return t
# matrix_tmp = np.matrix(change(A))*np.matrix(B)*np.matrix(change(B))
# matrix_c = []
# for i in range(len(matrix_tmp)):
#     matrix_c.append(matrix_tmp[i].tolist()[0])
# C = change(matrix_c)
# for item in C: #按照1 2 3 4格式输出。
#     print(" ".join(map(str,item)))

#给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。
# 你可以对一个单词进行如下三种操作：
# 插入一个字符
# 删除一个字符
# 替换一个字符
# s1 = "zoologicoarchaeologist"
# s2 = "zoogeologist"
# s1 = "sea"
# s2 = "eat"
# m = len(s1)
# n = len(s2)
# if m == 0 or n == 0:
#     print(n+m)
# matrix = [[0]*(m+1) for x in range(n+1)] #构建(n+1)*(m+1)的矩阵，首行首列存放0-m 0-n的数值：
# for i in range(1,n+1):
#     matrix[i][0] = i
# for i in range(1,m+1):
#     matrix[0][i] = i

# for i in range(1,n+1):
#     for j in range(1,m+1):
#         if s2[i-1] == s1[j-1]:
#             matrix[i][j] = matrix[i-1][j-1] #若匹配字符相同，则等于上一次的匹配结果，即[i-1][j-1]
#         else: #如果不同，则等于其他三次的最小结果再加1.
#             tmp = min(matrix[i-1][j] + 1, matrix[i-1][j-1] + 1, matrix[i][j-1] + 1)
#             matrix[i][j] = tmp 
# print(matrix[-1][-1]) #末尾元素即最终结果


#合并区间：
# mer = []
# intervals.append(newInterval)
# intervals.sort() #合并之后排序
# mer = []
# for inter in intervals:
#     if not mer or mer[-1][-1] < inter[0]: #mer最后一个元素右端点小于inter左端点，无重叠直接append
#         mer.append(inter)
#     else:
#         mer[-1][-1] = max(mer[-1][1], inter[1]) #更新当前右端点
# return mer


# 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
# '.' 匹配任意单个字符
# '*' 匹配零个或多个前面的那一个元素
s = ''
p = ''
#法1：
# pattern = re.compile(p)
# result = pattern.findall(s)
# if len(result) != 0 and result[0] == s:
#     print(True)
# else:
#     print(False)
#法2：动态规划：
# def ismatch(p,s):
#     m = len(p)
#     n = len(s)
#     matrix_dp = [[0]*(n + 1) for x in range(m + 1)]
#     matrix_dp[0][0] = 1
#     for i in range(m):
#         if p[i] == '*' and matrix_dp[i - 1][0]:
#             matrix_dp[i + 1][0] = 1
#     for j in range(1, m + 1):
#         for i in range(1, n + 1):
#             if p[j - 1] == s[i - 1] or p[j - 1] == '.':
#                 matrix_dp[j][i] = matrix_dp[j - 1][i - 1]
#             elif p[j - 1] == '*': #p遇到 * 号
#                 if s[i - 1] == p[j - 2] or p[j - 2] == '.': #p的上一个字符等于s当前字符，或者上一字符为 . ,赋值[j][i-1]
#                                         #*号单匹配，                #没有匹配               #p上一位为 . 或消去一位。
#                     matrix_dp[j][i] = matrix_dp[j][i - 1] or matrix_dp[j - 1][i] or matrix_dp[j - 2][i]
#                 elif s[i - 1] != p[j - 2]: #不相等，那么 p当前的*+前一个字符无法匹配s当前字符，那就s当前字符和p的上上个字符去匹配。
#                     matrix_dp[j][i] = matrix_dp[j-2][i]
#     return matrix_dp[-1][-1]



#不同子序列：
# 给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。
#一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
#动态规划：
# def numDistinct(self, s: str, t: str) -> int:
#     m = len(s)
#     n = len(t)
#     if n == 0:
#         return 1
#     if m == 0:
#         return 0
#     nums = [[0]*m for x in range(n)] 
#     for i in range(m):
#         if s[i] == t[0]:
#             tmp = nums[0][i-1] if i != 0 else 0
#             for j in range(i,m):
#                 nums[0][j] = 1 + tmp
#     for i in range(1, n):
#         for j in range(i, m):
#             if s[j] == t[i]: #t当前字符等于s当前字符，匹配s的前面字符当中包含多少个t的前面字符个数 + t的当前字符个数
#                 nums[i][j] = nums[i-1][j - 1]+nums[i][j-1]           
#             else:
#                 nums[i][j] = nums[i][j - 1] 
#     return nums[-1][-1]


# st = 'abbabbabb'
# # st = input()
# print(st)
# def match(s1,s2):#匹配s2是否是s1的循环节
#     print('in:',s1, s2)
#     m = len(s2)
#     n = len(s1)
#     if n%m != 0 or s1[:m] != s2:
#         return False
#     x = n/m
#     flag = True
#     for i in range(1,int(x)+1):
#         if s1[m*(i-1):m*i] != s2:
#             flag = False
#             return False
#     return flag
# mat = []
# for i in range(len(st)):
#     mark = 0
#     if len(mat)!=0:
#         if 1 in mat:
#             mark = 1 + mat.index(1)
#     print(st[:i+1])
#     print(match(st,st[:i+1]))
#     print('mark:',mark)
#     if mark>0:
#         if match(st,st[:i+1]) or match(st,st[i+1-mark:i+1]):
#             mat.append(1)
#         else:
#             mat.append(0)
#     else:
#         if match(st,st[:i+1]):
#             mat.append(1)
#         else:
#             mat.append(0)
# print(mat)


#最长有效括号
# 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。
# s = ")()())"
#法1：从左向右从右向左，各循环一遍，判断最长，两个取最大，防止出现((()的情况。
#从左到右遍历：
# l, r, m = 0, 0, 0
# t = len(s)
# for i in range(t):
#     if s[i] == '(':
#         l += 1
#     else:
#         r += 1
#     if l == r:
#         m = max(m, 2 * r)
#     if r > l: #不匹配，归零。
#         l, r = 0, 0
# l, r = 0, 0
# #从又往左遍历：防止出现(((),即右括号在右边的情况无法匹配：
# for i in range(t - 1, -1, -1):
#     if s[i] == ')':
#         r += 1
#     else:
#         l += 1
#     if l == r:
#         m = max(m, l * 2)
#     if l > r:
#         l, r = 0, 0
# return m
#法2：动态规划：
# if len(s) == 0 :
#     return 0
# dp = [0 * x for x in range(len(s)+1)] #初始化动态数组
# for i in range(1, len(s) + 1):
#     if s[i - 1] == '(': #如果是左括号，为0
#         dp[i] = 0
#     if s[i - 1] == ')' and i - 1 > 0 and s[i - 2] == '(': #()匹配
#             dp[i] = dp[i - 2] + 2
#     #考虑()((()))这种情况，根据dp[i - 1]来判断
#     if s[i - 1] == ')' and i - dp[i - 1] - 1 > 0 and s[i - 2] == ')' and s[i - dp[i - 1] - 2] == '(':
#         dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]
# return max(dp)


#栈：
# s = "(()()(())"
# stack = [-1] #防止第一个字符为')',栈为空无法弹出。
# count = 0
# for i in range(len(s)):
#     if s[i] == '(':
#         stack.append(i)
#     else: #')'
#         stack.pop() #弹出栈顶的'('
#         if len(stack) == 0: #防止第一个符号为')',栈顶弹出后为空，要把i放进去。
#             stack.append(i)
#         else:
#             count = max(count, i - stack[-1])
# print(count)


#通配符匹配：给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
# '?' 可以匹配任何单个字符。
# '*' 可以匹配任意字符串（包括空字符串）。#？匹配单个,不能匹配空字符，* 号匹配任意长度
# def isMatch(s, p):
#     m = len(s)
#     n = len(p)
#     dp =[[0] * (m + 1) for _ in range(n + 1) ]  
#     dp[0][0] = 1
#     for i in range(1, n + 1):
#         if p[i - 1] == '*': #问号无法匹配，只有*号可能匹配
#             dp[i][0] = dp[i - 1][0]
#     for i in range(1, n + 1):
#         for j in range(1, m + 1):
#             if s[j - 1] == p[i - 1] or p[i - 1] == '?':
#                 dp[i][j] = dp[i - 1][j - 1]
#             elif p[i - 1] == '*':
#                 dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
#     return dp[-1][-1]


#给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
# 求在该柱状图中，能够勾勒出来的矩形的最大面积。
# heights = [9046155,17522430,44186957,40374643,77652689,89027934,97586333,68834337,62979669,1783127,29339118,83907628,48067922,22843915,11027247,73603247,32376863,12448072,7086475,2369889,5064817,88893600,61558880,77108330,32113014,21324782,28294417,18403046,39022240,58687324,80978280,584748,76209754,25165237,40959391,6378795,66709524,38545724,75213133,29689193,92845203,4552251,13596821,40913125,27396166,24624068,67032725,12289382,89588493,74119200,14659271,94653310,15529152,28734503,24277993,47642166,50059286,52572410,18561565,89081526,11259734,99539845,42182626,39985840,24705083,83142017,46364635,43930959,74204093,74094120,73620152,67049296,31162724,87216973,7962422,58558890,64357394,27511499,23364624,53945887,1630699,38023896,1115549,69676203,66758399,25393542,17318370,16817685,30482304,88396287,58415564,94258390,87936132,598190,34244230,65157567,36256560,80608866,9088526,10460653,7219338,82708678,77509950,38382062,22442004,37988724,49457305,39315750,65500223,72821929,93261637,19647274,63362177,46893538,89323477,30120577,24803433,59158199,99454614,55285737,47554486,10386530,2060480,88006971,63501073,36304710,53164538,99757633,69429928,14769417,62734638,76649267,49994447,40244588,15031329,24952803,30749664,64488634,64268553,48766239,89826916,10046542,68413513,53189093,56940081,10253343,83309670,81743514,69411542,35280637,89545603,69482381,98183519,91606083,57489352,61684592,27910794,63170242,13958577,49857074,30456011,76693216,26506341,80450459,69454156,94054023,5403262,52720173,11059009,22188168,1486412,885925,32234710,22416278,54075019,89174791,32669621,89901041,23434657,54597515,77698030,65496613,24079896,75881550,57102696,34085600,90082494,37529842,97255843,4041072,87386917,27711854,33250640,66409610,60678665,2704796,60463633,18598280,7941321,24038995,40786448,9427734,24924920,73021158,31844012,31516291,14712302,17029985,21417333,38146959,71627500,99115363,56159924,48223749,27513265,13262621,82309349,17595760,50792463,32081544,74153184,90695732,12309751,7403824,57105343,72988416,62624972,70085328,91586696,70566294,94124323,32373144,32510380,71565596,57910655,16870744,3081887,72622957,33900729,24499220,63286268,5528229,76130936,19446193,6268330,56160553,85225166,88577680,73756313,36017629,20659224,425849,79229714,32968975,60346025,88851409,58473744,22970998,58936737,50060440,46053644,5577413,34949937,31080376,77143009,92860592,47951120,80224896,65483549,81851849,57240469,81286169,39896430,85887757,732362,46164761,42048310,38473880,87258793,68320976,74491510,7918017,68746825,6237576,93403345,29092851,95088985,51877089,4580201,6542074,54453881,3150197,12119487,89403818,34230573,89262496,82264410,34698045,22003745,264311,16549894,31760566,81550481,8962676,70164675,34799195,7643789,64729337,73273076,94902582,85566665,280938,2820600,6829843,59034866,48740297,88439046,54123851,617386,45535599,60665925,7587619,48685796,72785413,96991438,35432721,14564261,31772200,70130766,89084358,32036512,39197012,73361276,66103345,48159688,96042303,53418892,55803478,13287993,26691968,3222412,98854658,79489258,6043012,5684501,38524124,7299661,94123547,45164327,60433399,39659146,5830253,68021019,40861294,31132018,65012457,76294015,98212631,96784657,98941133,39813342,81337521,38138145,65690970,47440866,38814186,61733274,53376111,47134016,75021267,32584431,50356428,26392277,12073690,8915793,32076779,3114166,16215454,78716678,794846,76648854,70892177,6625099,44669873,64269823,90273469,62198682,93080191,41002452,11499691,92021324,80815794,92837213,82675822,46506765,92794431,21490008,60756391,46170542,68624024,88294010,78754974,18980452,14686287,43345016,80412597,99279418,98975534,96628052,77996097,99770380,73276906,1404626,58911831,70463131,65674449,49185300,32661813,58754640,42704105,44161504,3292317,23519899,89515069,85968139,22543016,82309501,7458147,35815759,80996395,28598523,24109769,12267721,95327,91312409,8129089,80507925,90591827,7104624,77135977,21104276,59391356,2929235,22508902,18303188,73392366,40699704,20004840,6054179,51970696,62708945,2732035,55263013,38745197,92247105,93747504,13804565,27072958,53722003,2136677,8069353,82320526,26246446,72853427,82415854,70075207,80982516,15440131,60667035,40603492,45092460,81771311,99994849,48021695,56796566,70814389,21414061,50012622,43335581,79984592,1983318,6044527,35232979,9762684,97306076,27480084,3510188,63626993,7069394,57232192,65763670,15138748,92069070,44526469,40508527,27001276,14601676,21491043,42441407,75268711,14610888,40050219,9556375,67122089,88071914,66352941,37936478,62002327,16365563,81272059,94503271,70865233,39832938,29736251,33144269,37139014,9732687,89170810,53282360,16802082,46403002,19046030,84457182,90988424,63572499,24965709,17989701,30690528,98973104,12947460,5959239,13583992,52997680,68031966,80706081,93585946,34384907,71158911,8104626,3266822,52430971,2607897,26648408,44780261,32344148,59792677,34435628,42076836,48963487,87717988,11395270,47882841,59280370,95852452,91387618,75369222,20818161,61893671,6059750,19791265,74841131,64535341,85891610,80355163,32567308,19114043,26457462,19468567,42789307,34562088,75251742,95220278,37169985,1900150,92516891,22030486,14209179,26952519,16623674,15689019,67186859,28018944,63571860,26467230,23871396,54959478,1836452,97205909,16853149,60412554,69513526,44210633,24947895,55405136,77082148,10031555,27035532,56055962,82016475,69824839,90618050,57268217,17561469,80304388,11684719,10078360,2334874,78410250,89547232,71474900,94099269,56734091,99493844,10187482,35717673,23365240,65146960,37554125,73087501,34516462,50483031,42601027,31243447,27947279,50522516,60841947,37978834,77558048,16897910,19995309,47382887,60032312,29779878,17460708,40336700,93980949,80055420,95187926,72391200,69602652,66662826,19006821,78853096,66156670,29194303,14570769,42038262,46857616,4641247,15125763,33890430,55124278,57726791,65133877,83071557,8249307,78492176,73566744,38323707,95390086,46078405,38222946,55422399,75858284,55683654,95759099,22355585,35739074,43463378,47263137,57858079,10126204,66269959,89227527,76282875,47980614,3798296,70837489,94838230,60955895,85963253,28728660,68596526,96206396,46378889,4184435,56972055,24871066,77751179,95295762,20261152,76345937,33518708,28199903,4720573,89202362,76475355,27076158,77457788,19938733,26855648,87832219,30064937,93125607,77059746,58864164,41106221,33374395,82218006,88460804,94330290,68181259,69705816,15443168,16904007,16084706,19627604,73876062,93472124,49895135,69171824,66249628,26241072,2690532,94449532,83477997,44409246,23441239,10554156,74383386,43379972,37409804,14731958,25961261,83051763,91791704,37341778,76674336,77682451,19559784,65135140,72012742,40257395,34840957,39972262,57161402,3442015,12116218,31037464,96914139,62011354,52725640,63163767,40768778,55416172,10129651,24246776,52341770,33570890,87317284,26725156,29467214,77243440,41457114,55428476,60295203,85765171,45286606,36969539,63447622,64846390,54621032,87976716,57620137,41978341,27948979,14781539,45420356,40065197,98335355,94850847,54592903,51060995,58014614,47878034,58993519,20660618,72124810,11335289,54231508,11958446,90576797,83698723,89201886,84550264,91643551,2013441,22831787,36930157,38982980,86279409,54292899,46120364,26772478,11913036,40615057,7237809,79210927,38551765,99819358,77546282,33402612,54412262,81123629,43933579,2290296,40117148,64594197,26931458,3968789,18825705,38889904,94545586,55040780,80608142,31612202,46684331,82621583,54443989,83614488,74120915,40723399,90423739,20241280,20012229,2336775,60856337,27250038,34064054,99408103,27069396,11610336,85327067,33998010,45250317,29260646,88804658,85367465,46371195,15736116,89336254,17713253,7142372,36398193,72754033,87750514,68010395,19438365,70372097,22454385,3052853,44493013,15694136,93476593,17250645,35706365,48329720,30623334,15472755,82393775,82547789,95058503,46520463,20391209,29056514,91770781,2168207,70377524,29654598,48539403,38629993,71507205,66252656,45772365,7905398,39006689,86039232,75915793,58445054,8927681,98370178,14014260,5937046,66580666,60007205,75704043,2287031,60853277,6327378,70276138,95763404,41391519,65334642,42283868,61782728,46907508,86571001,63950936,17285032,68741951,12490339,55915025,40249156,31259347,54203743,670906,70266036,92759327,76586700,81227443,1687008,27473230,47758055,7624055,94053897,60281612,35844450,48857280,21134889,42171828,71649771,69414646,36079700,36984413,64214866,97862428,36408273,3302219,61813364,6209657,72044170,26820055,14641035,64809679,58079402,68844778,65480585,80861791,61604105,94583637,14605586,15807465,22056868,62363641,75947872,68627117,75161605,11792323,70000749,96296494,6480503,41650520,18227492,42560203,31151285,82442358,40422632,67559558,85744577,54752348,26285568,10305100,81572404,40926603,75114779,92168158,62287733,40595364,73029949,76408190,35179002,87635535,92215655,9752222,2515528,68163528,78379339,77677133,32472203,48380088,26489980,38952706,90030609,44717472,81512910,73698246,27159831,74451894,41257805,65420760]
# heights = [i for i in range(1000)]
#法1，暴力：超时
# max_area = 0
# m = len(heights)
# # if len(heights) == 1:
# #     return heights[0]
# for i in range(m):
#     for j in range(m - 1, i - 1, -1):
#         area = min(heights[i:j + 1]) * (j - i + 1)
#         max_area = max(max_area, area)
# print(max_area)
#法2：优化暴力解法：继续超时
# max_area = 0
# m = len(heights)
# # if len(heights) == 1:
# #     return heights[0]
# for i in range(m):
#     height_min = heights[i] #取第一个为基准
#     for j in range(i, m):
#         height_min = min(heights[j],height_min)  #利用上次的比较结果，每次都比较当前元素和上一次的最小值，而不是子数组，减少计算量
#         area = height_min * (j - i + 1)
#         max_area = max(max_area, area)
# print(max_area)

#法3，一遍遍历，对位置i，向两边找第一个小于它的位置，计算以i位置为高的最大其面积。
# max_area = 0
# for i in range(len(heights)):
#     left, right = i, i
#     while left >= 0 and heights[left] >= heights[i]:
#         left -= 1
#     while right < len(heights) and heights[right] >= heights[i]:
#         right += 1
#     max_area = max(max_area, (right - left - 1)*heights[i])
# print(max_area)

#法4，用栈：
# heights = [2,1,5,6,7,8,4]
# stack = []
# heights = [0] + heights + [0]
# max_area = 0
# for i in range(len(heights)):
#     while stack and heights[stack[-1]] > heights[i]:
#         tmp = stack.pop()
#         max_area = max(max_area, (i - stack[-1] - 1) * heights[tmp])
#     stack.append(i)
# print(max_area)

# heights = [0] + heights + [0] #前后加个0元素，避免第一个和最后一个元素无法计算，如果不加，可手推，会出错。
# stack = []
# max_area = 0
# for i in range(len(heights)):
#     while stack and heights[i] < heights[stack[-1]]: #当前元素小于栈顶，说明已出现右边较小值，则弹出栈顶，栈顶为左边小值。
#         t = stack.pop()
#         max_area = max(max_area, heights[t] * (i - stack[-1] -1))
#     stack.append(i) #当前元素大于栈顶，将当前元素加入栈中，
#     print(max_area)


#解码：一条包含字母 A-Z 的消息通过以下方式进行了编码：1-A, 26-Z
#给定数字串，输出有多少种解码方法。
#法1，递归（超时）
# s = '4124142412322141242534534234211242354235476867978523523522343564576548736564564535242354364353245234534534567634521422012'
# s = '100'
# def decodes(s):
#     for i in range(1, len(s)): #如果中间出现30或00的情况直接返回0
#         if (int(s[i-1]) > 2 and int(s[i]) == 0) or (s[i-1] == '0' and s[i] =='0'):
#             return 0
#     if s[0] == '0': #首位为0，NG
#         return 0
#     if int(s) <= 10 or int(s) == 20: #10或20一种
#         return 1
#     elif int(s) <= 26 and int(s)>10: #11-26之间两种
#         return 2
#     if int(s[-2:])<=26 and s[-2] != '0' and s[-1] != '0': #形如1016 = 101 + 10
#         return decodes(s[:len(s)-1]) + decodes(s[:len(s)-2])  
#     elif s[-2] == '0': #形如1007 = 100
#         return decodes(s[:len(s)-1])
#     elif int(s[-2:]) > 26: #形如1036 = 10
#         return decodes(s[:len(s)-1])
#     elif int(s[-2:]) == 10 or int(s[-2:]) == 20: #形如1010或1020 = 10
#         return decodes(s[:len(s)-2])
# print(decodes(s))

#动态规划，要考虑全面各种情况，0很繁琐：
# dp = []
# for i in range(1, len(s)): #如果中间出现30或00的情况直接返回0
#     if (int(s[i - 1]) > 2 and int(s[i]) == 0) or (s[i-1] == '0' and s[i] == '0'):
#         print(0)
# if s[0] == '0': #首位为0，NG
#     print(0)
# if len(s) == 1:
#     print(1)
# if len(s) >= 2: #初始化dp数组，构造好前两位，否则下面的for循环会下标出错。
#     if s[1] != '0' and int(s[:2]) <= 26:   
#         dp = [1, 2]
#     else:
#         dp=[1,1]
# for i in range(2, len(s)):
#     ss = s[:i + 1]
#     if s[i] == '0': #末尾为0，形如1220，1220 = 12，因为最后的0只能组成20，要看前面的12，即[i-2]
#         dp.append(dp[i - 2])
#     elif ss[i - 1] != '0': #前1位不为0，可能为12,15，不可能为10 20
#         if int(ss[-2:]) <= 26: #小于26，需要看前一位和前两位
#             dp.append(dp[i - 1] + dp[i - 2])
#         else:
#             dp.append(dp[i - 1]) #大于26，看前一位即可。
#     elif ss[i - 1] == '0': #形如12208，则12208 = 1220
#         dp.append(dp[i - 1])
    
# print(dp[-1])


# 不同的二叉搜索树：给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
#遍历1-n，以不同元素为根节点，可利用动态规划：
# n = 60
# dp = []
# # if n == 1: #两个基本最小单元，手动添加，n大于3开始动态规划。
# #     return 1
# # if n == 2:
# #     return 2
# dp = [1,1,2] #首位置一个0，以便下面的 j-1=0 或i-j=0 时计算。
# for i in range(3, n + 1):
#     tmp = 0 #计算每个i值的数量：
#     for j in range(1, i+1):
#         tmp += dp[j - 1]*dp[i - j] #中间的元素为根节点，数量就是前段数量*后段数量
#     dp.append(tmp)
# # return dp[-1]
# print(dp[-1])


# 买卖股票的最佳时机
# 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
# 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
# prices = [7,1,5,3,6,4]
# if len(prices) <= 1:
#     return 0
# max_price = 0
# mark = 0
# for i in range(1, len(prices)):
#     if prices[i] - prices[i - 1] >= prices[i] - prices[mark]: #更新下标
#         mark = i - 1
#     max_price = max(prices[i] - prices[i - 1], prices[i] - prices[mark], max_price)
# return max_price



# 按要求补齐数组：给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。
# def minPatches(nums, n):
#     #注意到，[1,2,4,8]可覆盖[1, 16), 而[1, 16) + 5可覆盖[1, 21).
#     add = 1 #右开区间端点
#     count = 0 #添加次数计数
#     i = 0 #下标
#     while add <= n: #从最小向最大扫描，终止条件为已覆盖n。
#         if i < len(nums) and nums[i] <= add: #nums[i]在覆盖区间内，只需把该值加到区间右端点即可，扩大区间
#             add += nums[i] #扩大右端点
#             i += 1 #右移
#         else: #右端点不能覆盖当前的nums[i]，则添加右端点值到数组，将覆盖范围扩大二倍至[1, 2*add]
#             add += add
#             count += 1    #计数一次
#     return count

#假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。
#输入:
# [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
# 输出:
# [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

#思路1：从最小的开始插入：1、定义一个身高列表，从身高数组中找到最矮身高，根据其k值，即前面比其高的人数，在身高列表中遍历其应该插入的位置，即前面的空位置或与其身高相等的数量之和应该等于k值，该位置就是其应该插入的位置。
# import copy
# people_copy = copy.copy(people)
# que = [0]*len(people)
# def minHeigh(peo): #拿到peo数组的最小身高元素
#     height = peo[0][0]
#     inde = 0
#     for i in range(len(peo)):
#         if height > peo[i][0]:
#             height = peo[i][0]
#             inde = i
#     return  peo[inde], inde #返回 (h,k)和下标
# while people_copy:
#     # item = min(people_copy) #这两行等价于定义的minHeigh函数。
#     # index=people_copy.index(item)
#     item, index = minHeigh(people_copy) #find shortest person  
#     position = item[1] #拿到k
#     count = 0 #计数，从头到尾统计空位置和不小于当前身高的个数，下一个空位置即为需要插入的位置
#     for i in range(len(que)): #遍历 找到插入位置
#         if que[i] == 0 or que[i][0] >= item[0]:
#             count += 1
#         if que[i] == 0 and count > position: #位置为空，且前面空位置和大身高个数满足，插入。
#             que[i] = item #插入
#             break   #跳出循环
#     del people_copy[index] #delete shortest    #从身高队列删除已插入的身高   

#法2：从大到小排序，如果身高相同，根据k值从小到大排序，然后逐个根据k值插入：
# people.sort(key = lambda x: [-x[0], x[1]]) #两个key值，从大到小排序, 排序后[7,0]在前,[7,1]在后。
# que = []
# for item in people:
#     que.insert(item[1], item)
# return que


# 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
# 输入: "25525511135"
# 输出: ["255.255.11.135", "255.255.111.35"]
# def restoreIpAddresses(s):
#     res = []
#     def track(s, ip):
#         if len(ip) ==4 and not s:
#             t = '.'.join(ip)
#             res.append(t)
#             return
#         if len(ip) == 4 and s:
#             return 
#         for i in range(min(3, len(s))):
#             tmp = s[:i + 1]
#             if int(tmp) <= 255:
#                 if len(tmp) > 1 and tmp[0] == '0':
#                     pass
#                 else:
#                     ip.append(tmp)
#                     track(s[i+1:], ip)
#                     ip.pop()
#     track(s, ip = [])
#     return res




# 根据一棵树的前序遍历与中序遍历构造二叉树。
# 注意:
# 你可以假设树中没有重复的元素。
# 例如，给出
# 前序遍历 preorder = [3,9,20,15,7]
# 中序遍历 inorder = [9,3,15,20,7]
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# def buildTree(preorder, inorder) :
#     if len(preorder) == 0:
#         return None
#     root_value = preorder[0]
#     in_index = inorder.index(root_value)
#     root = TreeNode(root_value)
#     root.left = buildTree(preorder[1:in_index+1], inorder[:in_index])
#     root.right = buildTree(preorder[in_index+1:],inorder[in_index+1:])
#     return root

# str_input = input()
# A,B=str_input.split('<ctrip>')
# print(A,B)
# s1 = A
# s2 = B
# m = len(s1)
# n = len(s2)
# if m == 0 or n == 0:
#     print(n+m)
# matrix = [[0]*(m+1) for x in range(n+1)] #构建(n+1)*(m+1)的矩阵，首行首列存放0-m 0-n的数值：
# for i in range(1,n+1):
#     matrix[i][0] = i
# for i in range(1,m+1):
#     matrix[0][i] = i

# for i in range(1,n+1):
#     for j in range(1,m+1):
#         if s2[i-1] == s1[j-1]:
#             matrix[i][j] = matrix[i-1][j-1] #若匹配字符相同，则等于上一次的匹配结果，即[i-1][j-1]
#         else: #如果不同，则等于其他三次的最小结果再加1.
#             tmp = min(matrix[i-1][j] + 1, matrix[i-1][j-1] + 1, matrix[i][j-1] + 1)
#             matrix[i][j] = tmp 
# print(matrix[-1][-1])



# matrix = [[1,2],[3,4],[5,6]]
# if len(matrix) == 1:
#     print(','.join(map(str, matrix[0])))
# if len(matrix[0]) == 1:
#     res = []
#     for item in matrix:
#         res.append(item[0])
    
# m = len(matrix) - 1
# n = len(matrix[0]) - 1
# res = []
# def matrix_out(matrix, i, j, k):
#     # print(i,j,k)
# 	if i == j:
# 		for l in range(i, k+1):
# 			res.append(matrix[l][i])
# 	elif i == k:
# 		for l in range(i, j + 1):
# 			res.append(matrix[i][l])
# 	else:
# 		for l in range(i, j):
# 			res.append(matrix[i][l])
# 		for l in range(i, k):
# 			res.append(matrix[l][j])
# 		for l in range(i + 1, j+ 1)[::-1]:
# 			res.append(matrix[k][l])
# 		for l in range(i + 1, k + 1)[::-1]:
# 			res.append(matrix[l][i])
# x = 0
# while  x <= n-1 and x <= m -1:
# 	matrix_out(matrix, x, n-x, m-x)
# 	x += 1
# print(res)
# print(','.join(map(str,res)))



#二分法求数n的平方根：
# n=0.5
# low = 0
# high = int(n)
# mid = (low+high)/2
# if n > 0 and n <1:
#     high =1
#     low = 0
#     mid = (low+high)/2
# while abs(mid*mid - float(n)) > 0.00001:
#         if mid*mid < float(n):
#             low = mid
#         else:
#             high = mid
#         mid = (low+high)/2
# print(round(mid,4)) #四位精度，四舍五入



#第一站上a人，第二站上下相等，第三站开始，上车=前两上上车之和，下车=上一站上车，共N站，最后一站下m人，求第x站出发时人数。
#动态规划求解，通过递推公式
# a = 5
# n = 8
# m = 51
# x = 4
# dp = [[[1,0],[0,0],[1,0]],[[0,1],[0,1],[1,0]]] + [[[0,0],[0,0],[0,0]]* 1 for _ in range(n-3)]
# for i in range(2, n - 1):
#     dp[i][0][0] = dp[i-1][0][0] + dp[i - 2][0][0]
#     dp[i][0][1] = dp[i-1][0][1] + dp[i - 2][0][1]
#     dp[i][1][0] = dp[i-1][0][0]
#     dp[i][1][1] = dp[i-1][0][1]
#     dp[i][2][0] = dp[i-1][2][0] + dp[i][0][0] - dp[i][1][0]
#     dp[i][2][1] = dp[i-1][2][1] + dp[i][0][1] - dp[i][1][1]
# for item in dp:
#     print(item)
# b = int((m - a*dp[-1][-1][0])/dp[-1][-1][1])
# print("递推得第二站上车人数为%d"%b)
# x_out = dp[x-1][-1][0]*a + dp[x-1][-1][1]*b
# print("第%d站出发时人数为%d"%(x,x_out))

# for i in range(len(dp)):
#     board = a * dp[i][0][0] + b*dp[i][0][1]
#     out = a * dp[i][1][0] + b*dp[i][1][1]
#     go = a * dp[i][2][0] + b*dp[i][2][1]
#     print("第%d站，上车%d人，下车%d人，出发时%d人"%(i+1,board,out,go))



# A：E是第一
# B：我是第2名
# C：A垫底
# D：C不是第一
# E：D是第一
# 实际：第一和第二猜对了，E不是第二也不是第三，没有名次并列；
# nums = [1,2,3,4,5]
# def dele(nums, num): #去除num
#     tmp = []
#     for item in nums:
#         if item != num:
#             tmp.append(item)
#     return tmp
# dic = {'A':'e=1','B':'b=2','C':'a=5','D':'c=2345','E':'d=1'}
# person = ['A','B','C','D','E']
# for itemA in nums: #A
#     B = dele(nums, itemA)
#     for itemB in B: #B
#         C = dele(B, itemB)
#         for itemC in C: #C
#             D = dele(C, itemC)
#             for itemD in D: #D
#                 E = dele(D, itemD)
#                 for itemE in E: #E
#                     # print(itemA, itemB, itemC, itemD, itemE)
#                     a, b, c, d, e = itemA, itemB, itemC, itemD, itemE
#                     if e == 2 or e == 3: #E不是第二或第三
#                         continue
#                     tmp1 = sorted(list(map(int,[a,b,d,e])))
#                     #print(tmp1)
#                     # cc = ''
#                     # for item in tmp1:
#                     #     cc += str(item)
#                     AA = 'a=' + str(a)
#                     BB = 'b=' + str(b)
#                     CC = 'c=' + str(c)
#                     DD = 'd=' + str(d)
#                     EE = 'e=' + str(e)

#                     dicTmp = [AA,BB,CC,DD,EE]
#                     # print(dicTmp)
                    
#                     tmp = [int(a), int(b), int(c), int(d), int(e)]

#                     first = tmp.index(1) #数字
#                     second = tmp.index(2)
#                     third = tmp.index(3)
#                     forth = tmp.index(4)
#                     fifth = tmp.index(5)

#                     first_name = person[first] #字母
#                     second_name = person[second]
#                     third_name = person[third]
#                     forth_name = person[forth]
#                     fifth_name = person[fifth]
#                     # print(first_name, second_name,'\n', dic[first_name], dic[second_name], dic[third_name], dic[forth_name], dic[fifth_name])
#                     if dic[first_name] in dicTmp and dic[second_name] in dicTmp and dic[third_name] not in dicTmp and dic[forth_name] not in dicTmp and dic[fifth_name] not in dicTmp :
#                         print(itemA, itemB, itemC, itemD, itemE)
#                         print(dicTmp)
#                         print(first_name, second_name, dic[first_name], dic[second_name], dic[third_name], dic[forth_name], dic[fifth_name])


#最大流算法：
# import copy
# from collections import deque


# def hasPath(Gf, s, t, path):
#     # BFS algorithm
#     V = len(Gf)
#     visited = list(range(V))
#     for i in range(V):
#         visited[i] = False
#     visited[s] = True
#     queue = deque([s])
#     while queue:
#         temp = queue.popleft()
#         if temp == t:
#             return True
#         print("temp =", temp)
#         for i in range(V):
#             if not visited[i] and (Gf[temp][i] > 0):
#                 queue.append(i)
#                 visited[i] = True
#                 path[i] = temp   # record precursor
#     return visited[t]


# def max_flow(graph, s, t):
#     maxFlow = 0
#     Gf = copy.deepcopy(graph)
#     V = len(Gf)
#     path = list(range(V))
#     while hasPath(Gf, s, t, path):
#         min_flow = float('inf')

#         # find cf(p)
#         v = t
#         while v != s:
#             u = path[v]
#             min_flow = min(min_flow, Gf[u][v])
#             v = path[v]
#         print(min_flow)

#         # add flow in every edge of the augument path
#         v = t
#         while v != s:
#             u = path[v]
#             Gf[u][v] -= min_flow
#             Gf[v][u] += min_flow
#             v = path[v]

#         maxFlow += min_flow
#     return maxFlow

# M=0
# capacity = [
# [0,16,13,M,M,M],
# [M,0,10,12,M,M],
# [M,4,0,M,14,M],
# [M,M,9,0,M,20],
# [M,M,M,7,0,4],
# [M,M,M,M,M,0]
# ]

# flow = max_flow(capacity, 0, 5)
# print("flow =", flow)


#给定一个二叉树，判断其是否是一个有效的二叉搜索树。
#中序遍历：
# def inOrder(root):
#     if not root:
#         return 
#     inOrder(root.left)
#     inorder.append(root.val)
#     inOrder(root.right)
# inorder = []
# inOrder(root)
# if inorder != sorted(inorder) or len(inorder) != len(list(set(inorder))):
#     return False
# else:
#     return True

#栈：
# stack, inorder = [], float('-inf')
# while root or stack:
#     while root:
#         stack.append(root)
#         root = root.left
#     root = stack.pop()
#     if root.val <= inorder:
#         return False
#     inorder = root.val
#     root = root.right
# return True


#交学费：第一个人交8块，介绍一人返百分之二十是一块六，介绍五个人自己免费，被介绍人交八块，再介绍人还是这么规则，问，这个体系收费是人均几块钱
# price = 8
# person = 5
# import random
# max_person = 5000 #模拟点数量
# gene = 0 #级
# dev = 0 #发展人数
# total_price = 0 #总收费
# total_person = 0
# def iter(gene, total_person, total_price):
#     print(total_person, total_price)
#     if total_person >= max_person: #达到预定人数
#             return
#     x = random.randint(0, person) #发展的下线数量
#     print(x)
#     if x == 5:
#         total_price += 6.4
#     else:
#         total_price += 8
#     gene += 1
#     total_person += 1
#     for i in range(x):
#         iter(gene, total_person, total_price)
#         if total_person >= max_person: #达到预定人数
#             return

# iter(gene, total_person = 0, total_price = 0)
# print(total_person, total_price)



#堆排序
# from collections import deque
# L = deque([4,2,1,6,9,8,3,7,4,5,10,11])
# L.appendleft(0) #因为树结构根节点从1开始，左孩子节点是父节点2倍，所以对列表添加一个头节点。

# def heap_sort(L):
#     L_length = len(L) - 1 #因为添加了一个头元素，这里长度减去1。
#     first_sort_count = L_length // 2 #调整大根堆，从中间有子树的节点开始。
#     for i in range(first_sort_count): #将序列调整为大根堆，初始化。
#         heap_adjust(L, first_sort_count - i, L_length) #调用函数，从下往上，从右往左。
#     for i in range(L_length -1):
#         L = swap_param(L, 1, L_length - i) #交换堆顶和堆尾元素，下标从1开始，末尾元素L_length - i。
#         heap_adjust(L, 1, L_length - 1 - i) #重新调整堆，从根节点开始，到最后一个元素L_length - 1 - i。
#     return list(L)

# def heap_adjust(L, start, end): #调整最大堆，将子树的最大值调整到根节点位置
#     #start为根节点下标，end为最后一个下标
#     tmp = L[start] #暂存堆顶元素
#     i = start
#     j = 2 * i #从左子树根节点开始
#     while j <= end:
#         if j < end and L[j] < L[j + 1]: #寻找最大同层子节点下标，如果右节点比左节点大，j移到右节点。
#             j += 1
#         if tmp < L[j]: #根节点小于子树节点，将子树节点值给根节点，然后移动 i 和 j分别下移一层。
#             L[i] = L[j] #将目前大值给顶点
#             i = j
#             j = 2 * i
#         else: #不小于，即已经满足最大堆，然后break跳出，否则会报错越界。
#             break
#     L[i] = tmp #将最原始的根节点赋给当前的节点，因为当前节点已往上赋值了。
#     print("adjust:",L)

# def swap_param(L, i, j): #原地交换元素。
#     L[i], L[j] = L[j], L[i]
#     return L
# print(heap_sort(L)[1:])




#数组 S = [3,1,2,1,3,4], 求出所有长度从 2-n 的递增子数组，如[3，4]、[1，2，3，4]...
# nums = [3,1,2,1,3,4]
# res = []
# def check(num, k):
#     for j in range(k,len(nums)):
#         if nums[j] > num[-1]:
#             # print(num + [nums[j]])
#             if num + [nums[j]] not in res:
#                 res.append(num + [nums[j]])
#             check(num + [nums[j]], j + 1)
# for i in range(len(nums)):
#     check([nums[i]], i + 1)
# print(sorted(res))



# from itertools import combinations, permutations
# nums = ['+','-','*','/']
# n = list(permutations(nums,3))

# from operator import truediv, mul, add, sub
# opl = [truediv, mul, add, sub]


#24点游戏，给定4个数字的数组，能否加减乘除够24？
# def changeOp(op):
#     if op is add:
#         return '+'
#     if op is mul:
#         return '*'
#     if op is truediv:
#         return '/'
#     if op is sub:
        # return '-'
# import functools
# # @functools.lru_cache()
# def cal(nums):
#     if not nums:
#         return False
#     if len(nums) == 1:
#         return abs(nums[0] - 24) < 0.000006
#     for i in range(len(nums)):
#         for j in range(len(nums)):
#             if i != j:
#                 B = [nums[k] for k in range(len(nums)) if i != k != j] #除i、j之外的数字
#                 for op in (opl):
#                     if (op is add or op is mul) and j > i: #加法、乘法，满足交换律，a+b = b+a,所以用j>i剔除一种组合。
#                         continue 
#                     if op is not truediv or nums[j]: #运算符不是除，或者是除，但是分母不为零。
#                         B.append(op(nums[i], nums[j]))
#                         if cal(B):
#                             print(B, i, j, str(nums[i]) + changeOp(op) + str(nums[j]))
#                             tmp = [str(nums[i]) + changeOp(op) + str(nums[j])]
#                             res.append(tmp)
#                             return True
                            
#                         B.pop() #弹出，换种运算符
                   
#     return False
# res = []
# nums = [2, 1, 3, 4]
# print(cal(nums))
# print(res[::-1])

#逆波兰式求值
# tokens = ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
# from operator import truediv, mul, add, sub

# def Op(a, b, op):
#     print(a,b,op)
#     if op == '+':
#         return int(a) + int(b)
#     if op == '*':
#         return int(a) * int(b)
#     if op == '/':
#         return int(a) / int(b)
#     if op == '-':
#         return int(a) - int(b)
# def evalRPN(tokens):
#     stac = []
#     for i in range(len(tokens)):
#         if tokens[i].lstrip('-').isdigit(): #负数用isdigit会出错，截取掉左边的符号'-'.
#             stac.append(tokens[i])
#         else:
#             b = stac.pop()
#             a = stac.pop()
#             c = Op(a, b, tokens[i])
#             stac.append(c)
        
#         print(stac)
# evalRPN(tokens)


# 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。
# 你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。
# 请返回一个能打开保险箱的最短字符串。
# def crackSafe(n, k):
#     seen = set()
#     ans = []
#     def dfs(node):
#         for x in map(str, range(k)):
#             nei = node + x
#             if nei not in seen:
#                 seen.add(nei)
#                 dfs(nei[1:])
#                 ans.append(x)
#     dfs('0'*(n - 1)) #从n-1个0开始
#     print("".join(ans) + "0" * (n-1))

# crackSafe(3,5)


# print(eval('3*7-2'))


# 合并两个有序链表
#迭代法：
# def mergeTwoLists(l1, l2):
#     l_new = ListNode(-1)
#     tmp = l_new
#     while l1 and l2:
#         if l1.val <= l2.val:
#             tmp.next = l1
#             l1 = l1.next
#         else:
#             tmp.next = l2
#             l2 = l2.next
#         tmp = tmp.next
#     tmp.next = l1 if l1 else l2
#     return l_new.next


# 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现的数字。如：输入: 1->2->3->3->4->4->5，输出: 1->2->5
# def deleteDuplicates(head):
#         if not head:
#             return 
#         new = ListNode(head.val - 1) #创建一个新head，并链接到原链表,目的是有些从开头就重复。
#         new.next = head
#         tmp = new #复制头结点
#         while new.next and new.next.next:
#             if new.next.val == new.next.next.val:
#                 tt = new.next #暂存第一个重复值节点。
#                 try:
#                     while tt.val == tt.next.val: #往后遍历重复节点，防止重复节点在末尾，加try语句。
#                             tt = tt.next
#                 except:
#                     pass
#                 new.next = tt.next #将重复节点的下一节点链接到上一节点
#             else:
#                 new = new.next
#         return tmp.next #因为加入新头节点，返回第二个节点开始的链表。


# LeetCode 24: 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
# 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。给定 1->2->3->4, 你应该返回 2->1->4->3.

# def swapPairs(head):
#     #迭代法：
#     # temp_node = ListNode(0)
#     # temp_node.next = head
#     # tmp = temp_node
#     # while temp_node.next and temp_node.next.next:
#     #     t1 = temp_node.next
#     #     t2 = temp_node.next.next
#     #     t3 = temp_node.next.next.next
#     #     temp_node.next = t2
#     #     temp_node.next.next = t1
#     #     temp_node.next.next.next = t3
#     #     temp_node = temp_node.next.next
#     # return tmp.next
    
#     #递归法：
#     if not head or not head.next:
#         return head
#     temp = head.next
#     head.next = self.swapPairs(temp.next)
#     temp.next = head
#     return temp


#Leecode 312. 戳气球
# 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
# 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。
# 求所能获得硬币的最大数量。nums[-1] = nums[n] = 1。

# nums = [3,1,5,8]
# nums = [1] + nums + [1]
# # 初始化 dp
# l = len(nums)
# dp = [[0] * l for _ in range(l)]

# for i in range(2, len(nums)):
#     for j in range(len(nums) - i):
#         for k in range(j + 1,j + i):
#             dp[j][j+i] = max(dp[j][j+i], dp[j][k] + dp[k][i + j] + nums[j] * nums[k] * nums[i + j])
# print(dp[0][-1])




#LeetCode 179，给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。
#示例： 输入: [3,30,34,5,9]
# 输出: 9534330
# nums = [8,30,3,34,5,9]
# class LargerNumKey(str):
#     def __lt__(x, y):
#         print(x+y > y+x)
#         return x+y > y+x
# largest_num = '-'.join(sorted(map(str, nums), key=LargerNumKey))
# print(largest_num)

# #法2：相同前缀，比较循环数字大小，如32和34，转换为0.32323232 0.343434
# def tran(num): #自定义key函数
#     if num == '0':
#         return 0
#     l = len(num)
#     return int(num) / (10**l -1) #让num除以n个9就可得到以其为循环体的循环小数，如76/99 = 0.76767676...
# largest = ''.join(sorted(map(str, nums), key = tran, reverse = True))
# if largest[0] == '0':
#     return '0'
# else:
#     return largest



#桶排序1：最简单形式，桶间隔为1
# nums = [4,2,3,8,5,0,9,1,6,7,6,1]
# max_ = max(nums)
# min_ = min(nums)
# buc = [0 for _ in range(max_ - min_ + 1)] #长度
# for item in nums:
#     buc[item - min_] += 1 #计数
# res = [] #创建新数组
# tmp = min_ 
# for item in buc:
#     while item > 0: #重复几次
#         res.append(tmp)
#         item -= 1
#     tmp += 1
# print(res)

#桶排序2：设置桶数量
'''
import random, time
def bucket_insert(nums, num):#将数字num插入已排序数组nums中
    if nums[0] > num: #插入位置：i-1和i之间，需要判断i是否为首位
        nums = [num] + nums #直接拼接
        return nums
    flag = False
    for i in range(len(nums)):
        if nums[i] > num:
            flag = True #设置标记，防止遍历到最后一个无法识别。
            break
    if i == len(nums)-1 and not flag: #遍历到末尾都没法现比num大，说明需要插在末尾。
        nums = nums + [num]
    else:
        nums = nums[:i] + [num] + nums[i:]
    return nums
nums =[random.randint(0,100) for _ in range(10000)] #创建随机整数数组
# nums = [1,10000000,2]

start = time.time()
max_ = max(nums)
min_ = min(nums)
bucket = len(nums) - 1 #自定义桶的数量,默认数组长度减一,主要为了获取最大间距，如果数组元素平均，则相邻元素间隔相同，取平均间隔作为bucket范围，则最大差距会出现在相邻桶之间。
gap = (max_ - min_ + 1)/bucket #bucket范围,多加1，让bucket范围稍微大一点，以便所有元素都在区间内，防止在边界情况。
res = [[] for _ in range(bucket)]
for item in nums: #遍历数组
    bucket_index = int((item - min_)/gap * 1.0) #计算对应桶的索引
    if not res[bucket_index]: #该桶第一个元素，直接进入
        res[bucket_index].append(item)
    else: #非第一个，按找插入法插入该桶
        res[bucket_index] = bucket_insert(res[bucket_index], item) #调用插入函数
res_sort = []
#从小到大合并所有桶：
for item in res: 
    res_sort += item

#接下来的代码是为了解决Leetcode 164相邻元素最大差值的问题：
# max_gap = 0
# res_leecode = []
# for item in res:
#     if item: #去除空桶
#         tmp = [item[0],item[-1]] #如果只是单纯获取最大间距，则在之前的遍历数组 加入桶内的步骤当中，不需要插入排序，只需要放入桶内即可，这里直接取最大最小两个值即可。
#         res_leecode.append(tmp)
# print(res_leecode)
# if len(res_leecode) == 1: #只有一个bucket的情况：
#     print(res_leecode[0][1] - res_leecode[0][0])
# for i in range(1,len(res_leecode)):
#     max_gap = max(max_gap, res_leecode[i][0] - res_leecode[i - 1][1])

end = time.time()
print('桶排序运行时间:', end-start)
# print("最大间隔", max_gap)
#python内置排序比较：
start1 = time.time()
tt = sorted(nums)
end1 = time.time()
print('内置排序时间：',end1 - start1)
if res_sort == tt:
    print('排序正确！')
# '''


# print(ord('a')) #字符转ascci码
# import string
# res = dict.fromkeys(string.ascii_lowercase, 0) #生成26个字母字典。
# char = [chr(i) for i in range(97,123)] #生成26个字母表

# res = {}
# nums = [1,4,3,4,1,5]
# for i in range(len(nums)):
#     if nums[i] in res.keys():
#         print(True)
#     else:
#         res[nums[i]] = 1
# print(res,)

#折半查找：
# def half_sort(nums, num):
#     left, right = 0, len(nums) - 1
#     while left <= right:
#         mid  = (left + right) // 2
#         if nums[mid] == num:
#             print(mid)
#             return 
#         elif nums[mid] > num:
#             right = mid - 1
            
#         elif nums[mid] < num:
#             left = mid + 1
#             # mid  = (left + right) // 2
#     print(left, mid, right, nums[mid])
# half_sort([1,2,5,9],2)


#Leecode 220：给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。

# nums = [1,5,9,1,5,9]
# k = 2
# t = 3
'''
#法1，超时：
import  time
start = time.time()
k = len(nums) if k > len(nums) else k
for i in range(len(nums) - k):
    if i == 0:
        tmp = sorted(nums[i:i + k + 1])
        for j in range(len(tmp) - 1):
            if abs(tmp[j] - tmp[j + 1]) <= t:
                print('true')
    else:
        tmp.remove(nums[i - 1]) #移除首位
        #二分法，取代remove，时间并没有减少好像。：
        # l, r = 0, len(tmp) - 1
        # while l <= r:
        #     mid = (l + r) //2
        #     if tmp[mid] == nums[i - 1]:
        #         remove_index = mid
        #         break
        #     if tmp[mid] < nums[i - 1]:
        #         l = mid + 1
        #     elif tmp[mid] > nums[i - 1]:
        #         r = mid - 1
        # del(tmp[remove_index])
        # if remove_index != len(tmp) - 1:
        #     tmp = tmp[:remove_index] + tmp[remove_index+1:]
        # else:
        #     tmp = tmp[:-1]

        tt = nums[i + k] #需要添加的元素
        flag = False
        for j in range(len(tmp)):
            if tmp[j] > tt:
                flag = True
                break
        if j == len(tmp) - 1 and not flag: #插末尾
            tmp = tmp + [tt]
            if abs(tmp[-1] - tmp[-2]) <= t:
                print('true')
        else: #插中间
            tmp = tmp[:j] + [tt] + tmp[j:]
            if abs(tmp[j] - tmp[j-1]) <= t or abs(tmp[j] - tmp[j+1]) <= t:
                print('true')
end = time.time()
print('False', end - start)
'''
#利用桶，桶大小为t+1，每次保证桶内最多只有一个元素。
# bucket = {}
# gap = t + 1 #桶间隔为t+1保证每个桶内元素差不大于t。
# for i in range(len(nums)):
#     bucket_index = nums[i]//gap
#     if bucket_index in bucket: #桶已存在，则必有小于等于t存在。
#         print('True')
#     if bucket_index - 1 in bucket and abs(nums[i] - bucket[bucket_index - 1]) <= t: #左边桶
#         print('True')
#     if bucket_index + 1 in bucket and abs(nums[i] - bucket[bucket_index + 1]) <= t: #右边桶
#         print('True')
#     bucket[bucket_index] = nums[i]
#     if i >= k: #长度大于k，需要删减桶， #超过k时，需要把最前面的那个元素所在桶删掉，以便下一个循环时长度为k，这里条件是要 >=k。
#         del(bucket[nums[i - k]//gap])
#     print(bucket)
# print('False')



#Leetcode 274，给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。
#h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。
# citations = [3,0,6,1,5]
#法2，先排序
# citations = sorted(citations, reverse = True)
# h = 0
# for i in range(len(citations)):
#     if citations[i] >= i+1:
#         h += 1
#     else:
#         break
# return h

#法3，桶排序，设置桶数量为n+1个，最后一个桶放大于等于n的值，桶序号代表论文数量
# length = len(citations)
# bucket = [0 for _ in range(length + 1)]
# for i in range(length):
#     if citations[i] >= length:
#         bucket[length] += 1
#     else:
#         bucket[citations[i]] += 1
# h = 0
# for i in range(length, -1, -1):
#     h += bucket[i]
#     if h >= i:
#         return i


#归并排序
# def mergesort(res): #分割
#     if len(res) <= 1: #分割到最短长度
#         return res
#     mid = len(res)//2
#     left = mergesort(res[:mid]) #切割
#     right = mergesort(res[mid:])  
#     return merge(left, right) #对left和right合并排序。
# def merge(left, right): #合并
#     res = []
#     i, j = 0, 0
#     while i < len(left) and j < len(right):
#         if left[i] <= right[j]:
#             res.append(left[i])
#             i += 1
#         else:
#             res.append(right[j])
#             j += 1
#     if i >= len(left): #连接余下的数组：
#         res += right[j:]
#     else:
#         res += left[i:]
#     return res
# import random
# nums = [random.randint(1,100) for _ in range(10)]
# if __name__ == '__main__':
#     print(mergesort(nums))


'''
#用turtle库画小猪佩奇：
# from turtle import*
def turtal():
    
    def nose(x,y):#鼻子
        pu()
        goto(x,y)
        pd()
        seth(-30)
        begin_fill()
        a=0.4
        for i in range(120):
            if 0<=i<30 or 60<=i<90:
                a=a+0.08
                lt(3) #向左转3度
                fd(a) #向前走a的步长
            else:
                a=a-0.08
                lt(3)
                fd(a)
        end_fill()

        pu()
        seth(90)
        fd(25)
        seth(0)
        fd(10)
        pd()
        pencolor(255,155,192)
        seth(10)
        begin_fill()
        circle(5)
        color(160,82,45)
        end_fill()

        pu()
        seth(0)
        fd(20)
        pd()
        pencolor(255,155,192)
        seth(10)
        begin_fill()
        circle(5)
        color(160,82,45)
        end_fill()


    def head(x,y):#头
        color((255,155,192),"pink")
        pu()
        goto(x,y)
        seth(0)
        pd()
        begin_fill()
        seth(180)
        circle(300,-30)
        circle(100,-60)
        circle(80,-100)
        circle(150,-20)
        circle(60,-95)
        seth(161)
        circle(-300,15)
        pu()
        goto(-100,100)
        pd()
        seth(-30)
        a=0.4
        for i in range(60):
            if 0<=i<30 or 60<=i<90:
                a=a+0.08
                lt(3) #向左转3度
                fd(a) #向前走a的步长
            else:
                a=a-0.08
                lt(3)
                fd(a)
        end_fill()


    def ears(x,y): #耳朵
        color((255,155,192),"pink")
        pu()
        goto(x,y)
        pd()
        begin_fill()
        seth(100)
        circle(-50,50)
        circle(-10,120)
        circle(-50,54)
        end_fill()

        pu()
        seth(90)
        fd(-12)
        seth(0)
        fd(30)
        pd()
        begin_fill()
        seth(100)
        circle(-50,50)
        circle(-10,120)
        circle(-50,56)
        end_fill()


    def eyes(x,y):#眼睛
        color((255,155,192),"white")
        pu()
        seth(90)
        fd(-20)
        seth(0)
        fd(-95)
        pd()
        begin_fill()
        circle(15)
        end_fill()

        color("black")
        pu()
        seth(90)
        fd(12)
        seth(0)
        fd(-3)
        pd()
        begin_fill()
        circle(3)
        end_fill()

        color((255,155,192),"white")
        pu()
        seth(90)
        fd(-25)
        seth(0)
        fd(40)
        pd()
        begin_fill()
        circle(15)
        end_fill()

        color("black")
        pu()
        seth(90)
        fd(12)
        seth(0)
        fd(-3)
        pd()
        begin_fill()
        circle(3)
        end_fill()


    def cheek(x,y):#腮
        color((255,155,192))
        pu()
        goto(x,y)
        pd()
        seth(0)
        begin_fill()
        circle(30)
        end_fill()


    def mouth(x,y): #嘴
        color(239,69,19)
        pu()
        goto(x,y)
        pd()
        seth(-80)
        circle(30,40)
        circle(40,80)


    def body(x,y):#身体
        color("red",(255,99,71))
        pu()
        goto(x,y)
        pd()
        begin_fill()
        seth(-130)
        circle(100,10)
        circle(300,30)
        seth(0)
        fd(230)
        seth(90)
        circle(300,30)
        circle(100,3)
        color((255,155,192),(255,100,100))
        seth(-135)
        circle(-80,63)
        circle(-150,24)
        end_fill()


    def hands(x,y):#手
        color((255,155,192))
        pu()
        goto(x,y)
        pd()
        seth(-160)
        circle(300,15)
        pu()
        seth(90)
        fd(15)
        seth(0)
        fd(0)
        pd()
        seth(-10)
        circle(-20,90)

        pu()
        seth(90)
        fd(30)
        seth(0)
        fd(237)
        pd()
        seth(-20)
        circle(-300,15)
        pu()
        seth(90)
        fd(20)
        seth(0)
        fd(0)
        pd()
        seth(-170)
        circle(20,90)

    def foot(x,y):#脚
        pensize(10)
        color((240,128,128))
        pu()
        goto(x,y)
        pd()
        seth(-90)
        fd(40)
        seth(-180)
        color("black")
        pensize(15)
        fd(20)

        pensize(10)
        color((240,128,128))
        pu()
        seth(90)
        fd(40)
        seth(0)
        fd(90)
        pd()
        seth(-90)
        fd(40)
        seth(-180)
        color("black")
        pensize(15)
        fd(20)

    def tail(x,y):#尾巴
        pensize(4)
        color((255,155,192))
        pu()
        goto(x,y)
        pd()
        seth(0)
        circle(70,20)
        circle(10,330)
        circle(70,30)

    def setting():          #参数设置
        pensize(4)
        # hideturtle()
        colormode(255)
        color((255,155,192),"pink")
        setup(840,500)
        speed(0)

    def main():
        import time
        setting()           #画布、画笔设置
        # time.sleep(3)
        # goto(10,10)
        nose(-100,100)      #鼻子
        head(-69,167)       #头
        ears(0,160)         #耳朵
        eyes(0,140)         #眼睛
        cheek(80,10)        #腮
        mouth(-20,30)       #嘴
        body(-32,-8)        #身体
        hands(-56,-45)      #手
        foot(2,-177)        #脚
        tail(148,-155)      #尾巴
        
        done()              #结束

    main()
'''


#区间合并：
# def  merge():
    # intervals.sort()
    # mer = []
    # for item in intervals:
    #     if not mer or mer[-1][1] < item[0]:
    #         mer.append(item)
    #     else:
    #         mer[-1][1] = max(item[1], mer[-1][1])
    # return merv



#装饰器示例
# import time
# def log(func): #显示运行时间：将函数名作为参数传入装饰器，
#     def lll(*args, **kw): #接收任意参数，这里的exa函数有两个参数
#         start = time.time()
#         print("call:",func.__name__)
#         func(*args, **kw) #*args, **kw，接收任意参数
#         end = time.time()
#         print("run time:%d"%(end - start))
#     return lll

# @log
# def exa(x, y):
#     time.sleep(1)
#     print('x + y = %d'%(x+y))
# exa(1,4)




#利用filter产生素数
# def odd():
#     n = 1
#     while True: #产生奇数序列
#         n += 2
#         yield n #加入迭代器
# def check(n):#x是否能被n整除，不能就返回，供filter调用
#     return lambda x: x%n > 0 
# def prime():
#     yield 2
#     ii = odd()
#     while True:
#         x = next(ii) #从序列中取出元素
#         yield x #加入prime的迭代器
#         ii = filter(check(x), ii) #更新序列，第一遍筛除掉3的倍数，剩下的序列给迭代器ii，再下一轮筛掉5的倍数，依次进行
# for y in prime():
#     if y < 100:
#         print(y)
#     else:
#         break



#Leetcode 322 零钱兑换：
# 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
#法1，递归，一般会超时，这里设置一个flag数组(变量不可以)，找到后就更改值，然后在递归函数下判断该值,并返回，但是在无解情况下复杂度会导致超时。
# def decr(coins, target, stac):
#     if target <= 0 or flag[0]: #一起判断flag
#         return 
#     for i in range(len(coins)):
#         stac.append(coins[i])
#         t = target - coins[i] #消减后数值
#         decr(coins, t, stac)
#         if t == 0:
#             res.append(len(stac))
#             stac.pop()
#             flag[0]  = 1  #关键点：已找到，并修改变量。条件符号，递归逐层退出。
#         else:
#             stac.pop()
# coins = [186,419,83,408]
# amount = 6249
# stac = [] #存储兑换方法
# res = []
# flag = [0] #设置判断变量
# coins = sorted(coins, reverse = True) #逆序
# decr(coins, amount, stac)
# print(res)
# return res[0] if res else -1


#法2：动态规划：递推表达式： F[i] = min(F[i - Ci] + 1), 即当前金币数i减去零钱的F值再加上该零钱的1个。
# dp =[0] #初始化，0
# for i in range(1, amount + 1):
#     i_coin = amount + 1 #如果不能兑换，用amount+1表示。
#     for coin in coins:
#         if coin <= i:
#             i_coin = min(dp[i - coin] + 1, i_coin)
#     dp.append(i_coin)
# return -1 if dp[-1] > amount else dp[-1]

#法3：带备忘录的递归，记录每次的状态
# memo = [-2] * (amount + 1) #memo中存放索引对应的兑换方法,-2表示NG
# def changeCoin(coins, target, memo):
#     if target == 0: #已找到一种方案
#         return 0
#     if memo[target] != -2: #对应方案已存在备忘录中，直接返回
#         return memo[target]
#     coin_num = sys.maxsize
#     for coin in coins:
#         if target < coin:
#             continue
#         amount_tmp = changeCoin(coins, target - coin, memo)
#         if amount_tmp == -1: # -2 + 1 = -1，所以-1代表子问题无解，不必继续求下去
#             continue
#         coin_num = min(coin_num, amount_tmp + 1) #amount_tmp + 1即为当前coin下的兑换数。
#     memo[target] = coin_num if coin_num != sys.maxsize else -1
#     return memo[target]
# changeCoin(coins, amount, memo)
# return memo[amount]



# Leetcode394 字符串解码
# 给定一个经过编码的字符串，返回它解码后的字符串。
# 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
# 如：s = "3[a2[c]]", 返回 "accaccacc".
#借助栈来做这类题。
# def decodeString(s): #完全自己写，没有看题解。
#     if not s:
#         return ''
#     stack = []
#     for item in s:
#         if item == ']': #第一次遇到右括号，开始弹出直到遇到匹配左括号。
#             #1 获取字符：
#             string_tmp = [] #本次弹出‘[]'内的字符
#             stack_pop = stack.pop() #开始出栈，直到遇到'['.
#             while stack_pop != '[':
#                 string_tmp.append(stack_pop) #用数组暂存弹出字符，不用字符串，因为字符串在后面颠倒的时候会乱掉。
#                 stack_pop = stack.pop() #继续弹出。
#             string_tmp = ''.join(string_tmp[::-1]) #因为是倒着添加的，所以需要先翻转然后再连接成字符串

#             #2 获取数字：
#             string_num = '' #获取'[' 前面的数字
#             while stack and stack[-1].isdigit(): #前面是数字，取出,并且需要判断stack是否已为空
#                 string_num += stack.pop()
#             string_num = string_num[::-1] #取反获得数字

#             #3 拼接字符串：
#             string_combination = '' #获取数字和字符串后，拼接起来。
#             if string_num:
#                 for i in range(int(string_num)): #连续合并字符串。
#                     string_combination += string_tmp
            
#             #4 新字符串入栈：
#             stack.append(string_combination) #将合并后的字符串放入栈，完成此次出栈。
#         else:
#             stack.append(item) #不是右括号就将字符进栈。
#     # print(stack)
#     res = ''
#     for item in stack:
#         if not item.isdigit(): #如果只有数字，表示原字符串没有括号，将其舍去。
#             res += item
#     return res


# 146. LRU缓存机制
# 设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。
# 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
# 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
'''
from collections import deque, OrderedDict
class LRUCache:
    #法1：利用数组，速度慢。
    def __init__(self, capacity: int):
        self.capacity = capacity #长度
        self.LRU_key = [] #数组结构
        self.LRU_value = []
        self.LRU_dic = OrderedDict({})

    def get(self, key):
        if key in self.LRU_key: #存在返回，并更新时间
            key_index = self.LRU_key.index(key)
            return_result = self.LRU_value[key_index] 
            self.refresh(self.LRU_key, self.LRU_value, key_index) #更新结构
            return return_result
        else:  #不存在，返回-1.
            return -1
    def put(self, key, value):
        if key in self.LRU_key: #key已存在，进行覆盖并更新
            key_index = self.LRU_key.index(key)
            self.LRU_value[key_index] = value
            self.refresh(self.LRU_key, self.LRU_value, key_index) #更新结构
        elif len(self.LRU_key) < self.capacity: #未满
            self.LRU_key.append(key)
            self.LRU_value.append(value)
        else: #已满
            del self.LRU_key[0] #还是用数组做。
            self.LRU_key.append(key)
            del self.LRU_value[0]
            self.LRU_value.append(value)        
    def refresh(self, LRU_key, LRU_value, key_index): #更新列表
        if key_index < self.capacity - 1: #访问元素移动至右端
            self.LRU_key = self.LRU_key[:key_index] + self.LRU_key[key_index+1:] + [self.LRU_key[key_index]]
            self.LRU_value = self.LRU_value[:key_index] + self.LRU_value[key_index+1:] + [self.LRU_value[key_index]]
        else:
            pass


    #法2，利用字典，OrderedDict（可以将元素移到队首或队尾），速度快
    def _get(self, key):
        if key not in self.LRU_dic.keys():
            return -1
        else:
            self.LRU_dic.move_to_end(key) #移到队尾。
            return self.LRU_dic[key]
    def _put(self, key, value):
        print(self.LRU_dic)
        if key in self.LRU_dic:
            self.LRU_dic.move_to_end(key)
        self.LRU_dic[key] = value
        if len(self.LRU_dic) > self.capacity:
            self.LRU_dic.popitem(last = False)
'''
#测试：
# lru = LRUCache(2)
# lru.put(2,1)
# lru.put(1,1)
# lru.put(2,3)
# lru.put(4,1)
# print(lru.get(1)) #-1
# print(lru.get(2)) #3
# print(lru.get(4)) #1
# lru._put(2,1)
# lru._put(1,1)
# lru._put(2,3)
# lru._put(4,1)
# print(lru._get(1)) #-1
# print(lru._get(2)) #3
# print(lru._get(4)) #1



# d = OrderedDict({'a':1,'b':2,'c':3,'d':4})
# # print(d, k.keys(), len(d))
# d.move_to_end('a')#,last=False) #last为 False 移到队首
# d.move_to_end('b')#,last=False)
# d.move_to_end('c')#,last=False)
# d.move_to_end('d')#,last=False)
# print(d)
# d.popitem(last=True) #移除队尾
# print(d)
# d['e'] = 5
# print(d)




# Leetcode 15三数之和：
# 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
# def threeSum(nums):
#     if len(nums) <= 2:
#         return 
#     '''
#     res = []#法1，超时，时间复杂度O(n**2)
#     Hash = {}
#     for i in range(len(nums) - 1):
#         if nums[i] > 0:
#                 break
#         for j in range(i + 1, len(nums)):
#             if nums[j]  in Hash :#and (j not in dic[nums[j]]):
#                 temp = [nums[j]] + Hash[nums[j]]
#                 if sorted(temp) not in res:
#                     res.append(sorted(temp))
#                 pass
#             else:
#                 Hash[0 - nums[i] - nums[j]] = [nums[i], nums[j]]
#     '''

#     #法2，排序 + 双指针
#     nums = sorted(nums) #从小到大排序
#     for i in range(len(nums)):
#         if nums[i] > 0:
#             break
#         if i > 0 and nums[i] == nums[i - 1]: #如果相等，且上一轮已判断过，这次就可以直接跳过
#             continue
#         L, R = i + 1, len(nums) - 1
#         while L < R:
#             if nums[i] + nums[L] + nums[R] == 0:
#                 res.append([nums[i], nums[L], nums[R]])
#                 while L < R and nums[L] == nums[L + 1]: #重复相等值，避免出现重复答案，向前向后移动指针。
#                     L += 1
#                 while L < R and nums[R] == nums[R - 1]:
#                     R -= 1
#                 L += 1
#                 R -= 1
#             elif nums[i] + nums[L] + nums[R] > 0:
#                 R -= 1
#             else:
#                 L += 1
#     return res


# import bisect
# def threeSum(nums):
#     ans = []
#     counts = {}
#     for i in nums:
#         counts[i] = counts.get(i, 0) + 1
#     nums = sorted(counts)
#     for i, num in enumerate(nums):
#         if counts[num] > 1:
#             if num == 0:
#                 if counts[num] > 2:
#                     ans.append([0, 0, 0])
#             else:
#                 if -num*2 in counts:
#                     ans.append([num, num, -2*num])
#         if num < 0:
#             twosum = -num
#             left = bisect.bisect_left(nums, (twosum-nums[-1]), i+1)
#             for i in nums[left:bisect.bisect_right(nums, (twosum//2), left)]:
#                 j = twosum-i
#                 if j in counts and j != i:
#                     ans.append([num, i, j])
#     return ans
# nums = [-1, 0, 1, 2, -1, -4]
# print(threeSum(nums))
# counts = {}
# r = bisect.bisect_left(nums, 1, lo = 3)
# print(r)



# Leetcode 229，求众数：
# 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
# 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。
'''
def majorityElement(nums):
    if len(nums) < 3:
        return set(nums)
    length = len(nums)//3
    res = {}
    result = []
    #法1，遍历一遍，记下每个数字出现次数。
    # for i in range(len(nums)):
    #     if nums[i] not in res:
    #         res[nums[i]] = 0
    #     else:
    #         res[nums[i]] += 1
    #         if res[nums[i]] >= length and nums[i] not in result:
    #             result.append(nums[i])

    #法2，先排序，然后遍历一遍，利用计数器，如果和前一个相等，计数器加一，直到不相等，判断出现次数。
    nums = sorted(nums)
    count = 1
    tmp = nums[0] #初始值。
    for i in range(1, len(nums)):
        if nums[i] == tmp:
            count += 1
            if i != len(nums) - 1: #最后一个边界情况，不能continue了，否则会错过。
                continue
        if count > length:
            result.append(nums[i - 1])
        count = 1 #计数器归位。
        tmp = nums[i] #记下当前值，   
    return result
'''



# LeeCode 513. 找树左下角的值:
# 给定一个二叉树，在树的最后一行找到最左边的值。
#法1：层次遍历，记录每层的值，最后返回最后一层的第一个值。
# def __init__(self):
#     self.treeList = []
# def findLast(self, root, level):
#     if len(self.treeList) == level:
#         self.treeList.append([])
#     self.treeList[level].append(root.val)
#     if root.left:
#         self.findLast(root.left, level + 1)
#     if root.right:
#         self.findLast(root.right, level + 1)

#法2，利用tuple记录层与root，然后利用栈来弹出每个节点。
# def findLast(self, root):
#     temp = (0, root)
#     stac = [temp]
#     while stac:
#         depth, node = stac.pop()
#         if depth >temp[0]: #更新层，节点
#             temp = (depth, node)
#         if node.right: #先加入右，再加左，使下一个循环时，左节点最先pop
#             stac.append((depth + 1, node.right))
#         if node.left:
#             stac.append((depth + 1, node.left))
#     return temp
# def findBottomLeftValue(self, root):
    #法1调用：
    # self.findLast(root, 0)
    # return self.treeList[-1][0]
    #法2调用：
    # return self.findLast(root)[1].val



#Fibonacci数列的自顶向下的备忘录动态规划方法：
# def fib(n, memo):
#     if memo[n] != 0:
#         return memo[n]
#     if n <= 2:
#         memo[n] = 1
#     else:
#         memo[n] = fib(n-1, memo) + fib(n-2, memo)
#     print(n,memo)
#     return memo[n]
# if __name__ == '__main__':
#     n = 6
#     memo = [0]*(n+1)
#     x = fib(n, memo)
#     print(x)




# import requests
# url = 'http://127.0.0.1:5000/AIProcessor/upload'
# print(requests.get('http://127.0.0.1:5000/'))
# res = requests.post(url=url)
# print(res)

# 223. 矩形面积：
# 在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。
# 每个矩形由其左下顶点和右上顶点坐标表示
# def computeArea(A, B, C, D, E, F, G, H):
#     """
#     :type A: int
#     :type B: int
#     :type C: int
#     :type D: int
#     :type E: int
#     :type F: int
#     :type G: int
#     :type H: int
#     :rtype: int
#     """
#     #单个面积
#     s1 = calcArea(A, B, C, D)
#     s2 = calcArea(E, F, G, H)
#     #求重叠面积
#     w = max(0, max(G,C) - min(A, E) - abs(E-A) - abs(G-C))
#     H = max(0, max(D,H) - min(B,F) - abs(D-H) - abs(B-F))
#     s0 = w * H
#     #有无重叠：
#     print(s1 + s2 - s0)
# def calcArea(a, b, c, d):
#     return abs(a-c) * abs(b-d)
# computeArea(-3, 0, 3, 4, 0, -1, 9, 2)

#n类物品，每个物品有不同尺寸，求包含所有物品，每种物品只有一个的组合，且每个物品尺寸不能相同
# import copy
# test = [
#     [1,2,3], 
#     [2,4],
#     [5,8]
#     ]
# m = len(test)
# n=len(test[0])

# res = []

# for i in range(len(test[0])):
#     res.append([test[0][i]])
# print('初始化：\n',res)

# #首位进
# def appendV2(ele, re):
#     print('开始进', re, len(re))
#     for i in range(len(re) - 1, -1, -1):
#         if ele in re[i]:
#             print('重复，删', ele)
#             del re[i] #从res中删除重复值
#         else:
#             print('进', ele)
#             re[i].append(ele)
#     return re
# cons = []
# for i in range(1, m):
#     #暂存起始状态：
#     cons = copy.deepcopy(res)
#     print('开始暂存cons：', cons)
#     #首位
#     first = test[i][0]
#     res = appendV2(first, res)
#     print("第一轮结果", res, cons)

#     #后
#     for j in range(1, len(test[i])):
#         if test[i][j] == first:
#             continue
#         print('当前ele:', test[i][j])

#         temp = appendV2(test[i][j], cons)
#         print('暂存态：', temp)
#         #continue

#         res = res + temp
#         print('暂时合并结果：', res)
# print('最终组合结果：\n', res, '\n组合数量：',len(res))


# points = [[2,1],[2,2],[3,3]]
# angle = 90
# location = [1,1]
# points2 = [] #去中心化坐标
# angleList = [] #每个坐标角度
# for e in points:
#     points2.append([e[0] - location[0], e[1] - location[1]])
 


# board = [
#   ['A','B','C','E'],
#   ['S','F','C','S'],
#   ['A','D','E','E']
# ]

# mp = [[0 for _ in range(len(board[0]))] for _ in range(len(board))]
# print(mp)

# col = len(board[0])
# row = len(board)

# word1 = "ABCCED"
# word2 = "ABCB"
# direction = [[0,1], [0, -1], [-1,0], [1,0]]

# # DFS:
# path = []
# def dfs(i, j, s):
#     if len(word1) == s:
#         return True
#     if i < 0 or j < 0 or i >= row or j >= col:
#         return False
#     if mp[i][j]:
#         return False
    
#     if word1[s] != board[i][j]:
#         return False

#     mp[i][j] = True
#     rr = dfs(i + 1, j, s+1) or dfs(i - 1, j, s+1) or dfs(i, j + 1, s+1) or dfs(i, j - 1, s+1)
#     if rr:
#         return True
#     mp[i][j] = False
#     return False
# find = False
# for i in range(row):
#     for j in range(col):
        
#         r = dfs(i, j, 0)
#         if r:
#             find = True
#             print('Found it：\n', mp)
# if not find:
#     print('not found')


#n皇后问题：
#判断
# def could_replace(row, col):
#     return not (cols[col] + dia1[row + col] + dia2[row - col])
# #放置
# def place(r, c):
#     queen.append([r,c])
#     cols[c] = 1
#     dia1[r + c] = 1
#     dia2[r - c] = 1
# #删除回退
# def remove(r, c):
#     queen.pop()
#     cols[c] = 0
#     dia1[r + c] = 0
#     dia2[r - c] = 0

# def resolve():
#     so = []
#     for it in queen:
#         so.append('.' * it[1] + 'Q' + '.' * ( n - it[1] - 1))
#     res.append(so)
# #回溯主方法
# def back_trace(r = 0):
#     for i in range(n):
#         if(could_replace(r, i)): #判断是否可行
#             place(r, i) #放置逻辑
#             if r + 1 == n: #达到边界
#                 resolve()
#             else: #继续进行
#                 back_trace(r + 1)
#             remove(r, i)
# n = 5
# res = []
# cols = [0 for _ in range(n)] #列
# dia1 = [0 for _ in range(2 * n - 1)] #左下右上
# dia2 = [0 for _ in range(2 * n - 1)] #左上右下

# queen=[];

# back_trace()

# print('%d queens solutions:\n'%n, res)


# s='daaaadcdf'
# r = [s[0]]
# for i in range(1, len(s)):
#     if len(r) and r[-1] == s[i]:
#         r.pop()
#     else :
#         r.append(s[i])
# print("".join(r))

#LeeCode：980
# matrix = [[0,1,0,0],[0,0,0,0],[0,0,2,-1]]
# m = len(matrix)
# n = len(matrix[0])
# dire = [[-1,0],[1,0],[0,-1],[0,1]]
# def back_trace(i, j):
#     print(i,j)
#     if i < 0 or i >= m or j < 0 or j >= n:
#         return False
#     if matrix[i][j] == -1 or trace[i][j] == 1:
#         return False
#     if matrix[i][j] == 2:
#         return True
#     path.append([i,j])
#     print('path',path)
#     for d in dire:
#         ii = i + d[0]
#         jj = j + d[1]
#         trace[i][j] = 1
#         print(ii,jj)
#         t = back_trace(ii, jj)
#         print('t',t)
#         if t:
#             print(path)
#             res.append(path)
#             return True
#         trace[i][j] = 0
#         path.pop()
#         continue
#         return False

# res = []
# path = []
# trace = [[0 for _ in range(n)] for _ in range(m)]
# for i in range(m):
#     for j in range(n):
#         if matrix[i][j] == 1:
#             t = back_trace(i,j)
#             print('res', res)
#             if t:
#                 print('res:\n', res)

#接雨水，解法1：动态编程
height=[0,1,0,2,1,0,1,3,2,1,2,1]
num = len(height)
# left = [0] * num
# right = [0] * num
# for i in range(1, num):
#     left[i] = max(height[i], left[i-1])
# for i in range(num - 2, -1, -1):
#     right[i] = max(right[i + 1], height[i])
# vol = 0
# for i in range(num):
#     t = min(left[i] - height[i], right[i] -height[i])
#     if t<0:
#         t= 0

#     vol += t

#解法2：双指针
# left = 0
# right = num - 1
# left_max = 0
# right_max = 0
# vol = 0
# while left < right:
#     #当左边低右边高时，有理由相信水的高度决定于左边，反之决定于右边。
#     if height[left] < height[right]:
#         if height[left] <= left_max:
#             vol += (left_max - height[left])
#         else:
#             left_max = height[left]
#         left += 1
#     else:
#         if height[right] <= right_max:
#             vol += (right_max - height[right])
#         else:
#             right_max = height[right]
#         right -= 1
# print(vol)




#LeeCode114: 二叉树展开为链表
# 给你二叉树的根结点 root ，请你将它展开为一个单链表：
# 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
# 展开后的单链表应该与二叉树 先序遍历 顺序相同。
# 输入：root = [1,2,5,3,4,null,6]
# 输出：[1,null,2,null,3,null,4,null,5,null,6]

# def flatten(root):
#     #思路就是将一个节点的右子树挂在左子树的最右节点，然后将节点左子树挂在右子树，左子树赋空
#     while root:
#         if root.left == None:
#             root = root.right
#         else:
#             pre = root.left
#             #找左子树的最右子节点
#             while pre.right:
#                 pre = pre.right
#             pre.right = root.right
#             root.right = root.left
#             root.left = None
#             root = root.right
# root = [1,2,5,3,4,null,6]
# print(flatten(root))



#排列组合1:
# candidates =[3,1,3,5,2,4,6]
# target = 6
# res = []
# stack=[]
# def track(nums, tmp):
#     if not nums:
#         res.append(tmp[:])
#         return
#     for i in range(len(nums)):
#         tmp.append(nums[i])
#         num = nums[:]
#         del num[i]
#         track(num, tmp)
#         tmp.pop()
# track(candidates,stack)

#排列组合2:
# def track(nums, tmp):
#     if not nums:
#         if tmp not in res:
#             res.append(tmp[:])
#         return
#     for i in range(len(nums)):
#         tmp.append(nums[i])
#         num = nums[:]
#         del num[i]
#         track(num, tmp)
#         tmp.pop()
# track(candidates,stack)
# print(res)

###总和等于target的排列组合：
# def track(nums, tmp):
#     if sum(tmp) == target:
#         if tmp not in res:
#             res.append(tmp[:])
#         return
#     if not nums:
#         return
#     for i in range(len(nums)):
#         tmp.append(nums[i])
#         num = nums[:]
#         del num[i]
#         track(num, tmp)
#         tmp.pop()
# track(candidates,stack)
# print(res)


###LeeCode 63 不同路径 II 动态规划
# 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
# 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
# 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
# 网格中的障碍物和空位置分别用 1 和 0 来表示
# obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
# if obstacleGrid[-1][-1] == 1 or obstacleGrid[0][0] == 1:
#     print(0)
# col = len(obstacleGrid[0])
# row = len(obstacleGrid)
# dp = [[0 for _ in range(col)] for _ in range(row)]

# for i in range(col):
#     if obstacleGrid[0][i] == 1:
#         dp[0][i] = 0
#         break
#     else:
#         dp[0][i] = 1
# for i in range(row):
#     if obstacleGrid[i][0] == 1:
#         dp[i][0] = 0
#         break
#     else:
#         dp[i][0] = 1
# for i in range(1, row):
#     for j in range(1, col):
#         if obstacleGrid[i][j] == 1:
#             dp[i][j] = 0
#         else:
#             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
# print(dp)


###LeeCode 980 不同路径 III
# 在二维网格 grid 上，有 4 种类型的方格：
# 1 表示起始方格。且只有一个起始方格。
# 2 表示结束方格，且只有一个结束方格。
# 0 表示我们可以走过的空方格。
# -1 表示我们无法跨越的障碍。
# 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。
# 每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。
path = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
print(path)